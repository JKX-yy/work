| **八月 · August** | **星期日** | **星期一** | **星期二** | **星期三** | **星期四** | **星期五** | **星期六** |
| ----------------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |
|                   |            |            |            |            |            |            |            |

# 一：任务安排时间表



| **八月 · August** | **星期日**                                                   | **星期一** | **星期二**                             | **星期三** | **星期四**                             | **星期五**                                            | **星期六**                                                   |
| :---------------- | :----------------------------------------------------------- | :--------- | :------------------------------------- | :--------- | :------------------------------------- | :---------------------------------------------------- | :----------------------------------------------------------- |
| **周次**          | **27**                                                       | **28**     | **29**                                 | **30**     | **31**                                 | **1**                                                 | **2**                                                        |
| **第31周**        |                                                              |            |                                        |            |                                        | 建军节                                                |                                                              |
| **周次**          | **3**                                                        | **4**      | **5**                                  | **6**      | **7**                                  | **8**                                                 | **9**                                                        |
| **第32周**        |                                                              |            |                                        |            |                                        | 立秋                                                  |                                                              |
| **周次**          | **10**                                                       | **11**     | **12**                                 | **13**     | **14**                                 | **15**                                                | **16**                                                       |
| **第33周**        |                                                              |            |                                        |            |                                        |                                                       |                                                              |
| **周次**          | **17**                                                       | **18**     | **19**                                 | **20**     | **21**                                 | **22**                                                | **23**                                                       |
| **第34周**        |                                                              |            |                                        |            |                                        |                                                       | 美团笔试（上午） 10:00:00 -- 12:00:00  小米（下午） 16:00 -17：30   （京东顺延了） 晚上6.15小鹏一面 |
| **周次**          | **24**                                                       | **25**     | **26**                                 | **27**     | **28**                                 | **29**                                                | **30**                                                       |
| **第35周**        | 文远知行笔试（晚上）                                                     2025-08-24 19:00:00                          2025-08-24 21:00:00 |            | 海尔测评三天内，零跑汽车笔试三天内完成 |            | 收到北方华创的电话约面没有时间等通知。 | 汇顶科技笔试2025年08月29日 19:00~2025年08月29日 21:00 | 下午两点半；面试零跑汽车大约半个小时。2：30   ， 晚上7：00-800京东笔试   (8月) 做个海尔英语测评吧，在投点简历 做个柏楚电子的笔试吧； |
| **周次**          | 31                                                           | **1**      | **2**                                  | **3**      | **4**                                  | **5**                                                 | **6**                                                        |
| **第36周**        |                                                              | (9月)      | (9月)                                  | (9月)      | (9月)                                  | (9月)                                                 | (9月)                                                        |





| **九月 · September** | **星期日**                                                   | **星期一**                                                | **星期二**                                                   | **星期三**                                                   | **星期四**                           | **星期五** | **星期六** |
| -------------------- | ------------------------------------------------------------ | --------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------ | ---------- | ---------- |
| **周次**             | **31**                                                       | **1**                                                     | **2**                                                        | **3**                                                        | **4**                                | **5**      | **6**      |
| **第36周**           | 泰凌微电子 晚上八点半                              摩尔线程 早八点到晚八点      海康测评 | 小鹏下午的面试：2025-09-01 16:55 (GMT+08:00) 海康威视测评 | 华创面试下午四点浙江大华技术股份有限公司邀请您参加在线测评。传音控股在线测评 | 立医疗软件工程师（C++）岗位**笔试链接生效时间：**2025-09-03 17:00:00 **笔试链接失效时间：**2025-09-03 19:30:00 | 汇顶科技面试： 2025-09-04 周四 19:00 |            |            |
| **周次**             | **7**                                                        | 8                                                         | 9                                                            | 10                                                           | 11                                   | 12         | 13         |
| **第37周**           |                                                              | 小米视频面试：2025-09-08 09:00                            |                                                              |                                                              |                                      |            |            |
| **周次**             | **14**                                                       | **15**                                                    | **16**                                                       | **17**                                                       | **18**                               | **19**     | **20**     |
| **第38周**           |                                                              |                                                           |                                                              |                                                              |                                      |            |            |
| **周次**             | **21**                                                       | **22**                                                    | **23**                                                       | **24**                                                       | **25**                               | **26**     | **27**     |
| **第39周**           |                                                              |                                                           | 秋分                                                         |                                                              |                                      |            |            |
| **周次**             | **28**                                                       | **29**                                                    | **30**                                                       | **1**                                                        | **2**                                | **3**      | **4**      |
| **第40周**           |                                                              |                                                           |                                                              | (10月)                                                       | (10月)                               | (10月)     | (10月)     |





# 南芯半导体-上海





## 一轮- AI面 5025-8-23:59之前完成面试



（1）自我介绍。重点介绍项目，2min


面试官您好，我是靳可心，本科毕业于东华大学自动化系，目前在山东大学控制科学与工程学院攻读控制工程硕士。

我的核心能力是嵌入式实时操作系统、多源数据融合控制、协议解析与机器人智能交互。从本科到现在，我做过四个项目，涵盖了 MCU 级 RTOS 控制，到基于 LLM 的机器人高层智能控制。

第一块能力，是基于 RTOS 的多任务并发处理。
在“双车协同”项目中，我利用线程分层设计和优先级管理完成两辆车传球动作控制在两秒内，实现双车通信、元素处理、控制任务互不干扰。

在“K210 垃圾巡检”项目中，把相机采集、物品识别、GPS定位、SD卡存储任务解耦，通过双缓 + DMA + 事件机制实现图片写入 SD 卡稳定在 125ms 内，不阻塞主流程。

第二块能力，是总线通信与协议解析的结构化设计。
我实现 UART/I2C/SPI 驱动 + DMA/IDLE/环形缓冲 + 状态机解析模式。
在双车协同中，支持不定长帧 + CRC16校验，成功解析双车间通信消息，保证 2 秒动作窗口同步和稳定。

在巡检项目中，我分别实现了 UBlox GPS 数据解析和手机蓝牙指令解析，通过多状态机和有效性判定，使定位和指令通信更稳定可靠。

第三块能力，是软硬件与智能控制层的融合扩展。
在“机器人智能抓取”和“技能迁移”两个研究型项目中，我将 ROS、Qt、LLM 与强化学习结合：一方面，实现了自然语言到机器人动作的语义解析；另一方面，通过“语义→奖励”映射提升奖励函数生成效率，构建迁移学习网络，使新任务学习速度大大提高。

技术上，我熟悉 C/C++、Python、RT-Thread、了解Linux 驱动基础、ROS，以及常用调试与性能分析方法。
我希望能在贵司的底层软件与嵌入式平台上，继续沉淀这套系统化方法，交付稳定、可扩展、易维护的模块。谢谢。





```
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行开发，对实时操作系统如 RT-Thread有实际项目经验。同时也熟悉一些基础的 Linux 驱动开发。
在硬件层面，我接触过 STM32 等 Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

我注意到贵岗位需要负责MCU产品线的固件开发和电路设计，这与我之前做的嵌入式系统项目非常契合。在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。同时我也积累了程序调试经验，能够快速定位程序问题。我相信这些经验能够帮助我快速胜任贵岗位的工作。
```



（2）你的职业规划？哪几点原因让你选择南芯？对公司和岗位有怎样的了解？

```
我的职业规划是希望在嵌入式软件领域持续深耕发展。短期内，我希望能快速融入团队，深入掌握公司MCU产品线的开发流程和技术要点，为项目贡献自己的力量。中长期来看，我希望能够逐步承担更重要的开发任务，参与系统架构设计，最终成长为一名能够独立解决复杂技术问题的嵌入式系统专家。

我选择南芯主要基于以下方面考虑：首先，南芯在电源管理和MCU领域的技术实力和行业地位有目共睹，为我们提供了很高的技术平台；其次，公司正处于快速发展阶段，这为我们年轻人提供了宝贵的成长机会和发挥空间，相信在这里能与优秀的同事们共同攻克有价值的技术难题。

我对这个岗位的理解是，它需要扎实的MCU软硬件开发能力、系统级问题分析能力和良好的文档编写能力。
贵司对代码质量和系统稳定性的重视令我十分认同。我在之前的项目中不仅独立完成过固件开发与调试工作，还特别注重通过模块化设计和状态机等机制提升代码质量，同时具备硬件调试和文档编写经验。相信这些经历能够让我快速胜任岗位要求，为团队创造价值。
```

(3) 高压状态下持续输出的经历

```
在本科期间，我参与了一个双车协同控制的项目，需要在截止日期前独立完成从硬件调试到算法实现的全部工作。当时我白天还要上专业课，因此主要的开发工作都集中在晚上，经常每天只睡4到5个小时，确实承受了不小的压力。

为了高效推进项目，我们首先将整个系统拆解为几个核心模块，包括图像处理、电机控制、传感器采集、机间通信和LCD监控等，并为每个模块设定了明确的周度和每日目标。这种方式让我们即便在高强度的工作中，也能持续看到阶段性的成果，有效保持了动力。

团队还坚持每晚进行15分钟的站会，同步进度、交流遇到的问题，并互相鼓励。这段经历不仅让我学会了在高压环境下保持专注、稳步推进工作，也锻炼了解决复杂工程问题的能力，最终我们顺利完成了项目。

```

### 双车项目

(4) 遇到的困难与解决   



```
在调试双车协同项目时，一个令我印象非常深刻的困难出现在速度环和方向环的整定阶段。当时基础调试已在实验环境下完成，但一上实际赛道，就发现小车在低速时还能正常循迹，一旦速度提升，就会因响应滞后发生剧烈振荡，最终冲出道外。

我们首先怀疑是PID参数调节不当，反复调整了多次比例、积分和微分参数，但效果甚微。为了彻底定位问题，我们尝试关闭速度环，仅测试方向环的控制效果，结果发现小车在小角度偏转时能够回正，但大角度时依然无法稳定。

随后我们开始排查硬件问题，检查了电机驱动性能、编码器反馈信号和电源稳定性，却仍未找到根本原因。在接近两周的高强度排查后，我们最终决定逐行审查代码。结果发现，在控制中断服务函数中误加入了一条printf调试输出语句，严重影响了控制的实时性——尽管它看起来只是一行简单的日志。

删除该语句后，系统实时性得到显著提升，双车最终实现了稳定快速的协同循迹。
当时作为初学者，我们对嵌入式实时性的理解还不够深入，犯了这个比较低级的错误。最初加printf只是为了调试方便，完全没有意识到它会在高频中断中带来这么大的性能开销。这段经历让我深刻体会到，嵌入式开发中看似微小的代码细节，在实际运行时都可能对系统产生重大影响，也让我从此特别关注中断函数的简洁性和实时性能优化。
```

5）是否请求帮助

```
在项目中出现高速振荡问题时，我们确实主动向师兄和线上社区寻求了帮助。得到的建议多集中在PID参数整定和硬件层面，例如：
“重新整定PID参数，特别注意微分项”；
“检查电机供电是否稳定，编码器信号是否有噪声”；
“用示波器看看PWM波形是否干净”。
我们认真尝试了这些方向：反复调节了PID参数、检查了电源和信号质量、甚至重新布局了电机驱动线路，但问题依然存在。

在通用建议无法解决问题后，我们决定回归代码层面，采用最基础但彻底的方法——逐行注释和分段测试。最终发现中断服务函数中一个用于调试的printf语句严重影响了系统实时性。删除后，系统性能立刻恢复正常。
这个过程让我深刻认识到：
外部建议有助于拓宽思路，但解决复杂问题往往需要自己深入细节；
嵌入式开发中，软件细节对实时性的影响可能比算法和硬件更隐蔽；
扎实的调试能力和不放弃的耐心，才是解决底层技术问题的关键。
```

### 单车K210项目

4) 遇到的困难与解决   

控制代码不是我做的，控制代码是别的同学在硬件定时中断中完成的，图像识别也是别的同学完成的。我主要完成剩下的任务，比如通信协议，RTT系统设计线程优先级，SD卡驱动，写入检测结果

- 我负责：系统总体调度结构、线程优先级策略、通信协议栈、事件机制、SD卡存储链路、检测结果组织与可靠写入                                 我主要把多源实时任务下的通信解析、线程调度和高延迟 SD 写入这几条“易互相干扰”的链路拆开，通过事件驱动 + 双缓冲 + 低优先级后台写策略，做到指令响应稳定、检测结果可靠落盘，同时不给控制与推理主链路添阻力。

```c
我在这个项目里遇到的最大难题是系统任务调度和实时性的平衡问题。

具体来说，我们系统有摄像头识别任务、GPS解析、蓝牙指令解析、SD卡写入这几个任务并行执行。最开始我设计时比较粗糙，把这些任务都设成差不多的优先级，结果出现了明显的问题：

首先是响应延迟：手机发控制指令过来，特别是在SD卡写文件的时候，延迟更严重。

然后是帧率不稳定：摄像头目标是15FPS，但经常掉到6-8FPS，而且很不均匀。

//还有蓝牙丢包：高频发指令时，我发现环形缓冲区的溢出计数在快速增长，说明数据在丢失。

我是这样排查的：先在关键路径打时间戳，发现SD写入时间在几十毫秒，而且这期间其他任务基本停滞。再仔细看代码，发现几个问题：一是任务优先级太平，SD卡阻塞其他任务，三是UART中断回调里做了太多解析工作。

解决方案是重新设计任务架构：

我把任务分成：硬实时（中断处理）、软实时（摄像头、协议解析、SD写入）。摄像头线程优先级最高，GPS和蓝牙解析其次，SD写入最低。

关键改进是把中断处理"瘦身"：摄像头中断只做三件事——清标志、翻双缓冲索引、发信号量，不再做任何业务逻辑。图像识别工作放到图像线程中。  蓝牙中断也只是把字节搬到环形缓冲区，真正的协议解析放到专门的线程里用状态机一个字节一个字节处理。

数据流重新设计：用事件机制代替轮询，比如只有检测到垃圾才触发SD写入事件。由于之前的写入与摄像头识别线程共用一个检测结果数据，写入前先把检测结果和GPS坐标"快照"到局部变量，立即释放锁，然后慢慢写文件，这样不会阻塞其他任务。

效果很明显：整个系统运行平顺了很多。

这个经验让我深刻理解了在资源受限的嵌入式系统上，任务优先级设计和中断处理瘦身的重要性，还有就是一定要用数据说话，不能凭感觉调优。
```





(6) 借助外部标准和多元意见


```c
城市垃圾巡检项目早期，我自己写了个简单的通信协议，能用，但扩展性差，错误处理也不完善。
团队内部讨论有人提了这个问题，我就去参考了开源项目的成熟通信协议，写了封包  解包  状态机   校验。 
    
我还请了两位有车载通信经验的导师帮我审查代码，并在修改后做了高负载压力测试。
最终协议稳定性提升很明显，后续加新功能几乎不用动底层。这个经历让我一直记得，对标成熟标准、主动听取不同领域的意见，是提升工程品质最快的方式。
```





# 小鹏一面



## 自我介绍

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。同时我也积累了程序调试经验，能够快速定位程序问题。我相信这些经验能够帮助我快速胜任贵岗位的工作。
```



## 第一个项目  基于智能交互的机器人综合抓取平台

### 描述一下这个项目：

本项目是国家自然科学基金课题的一部分，主要围绕三个核心任务：一是构建行为认知图谱，二是多任务行为规划与决策，三是我重点参与的面向智能自主作业的迁移强化学习相关内容。

为了整合并验证这几个模块的功能，需要搭建了一个集成化的可视化实验平台。就是我负责的项目一，    这个平台基于ROS、QT和大型语言模型（LLM）开发，能够实现从自然语言指令输入，经过LLM解析与任务规划，再到机器人自主执行的一整套闭环流程，整体上体现了较强的智能化特点。





### 分工：

在整个抓取平台的开发中，我主要负责可视化界面、仿真机器人与交互界面之间的通信模块，以及部分中间件的实现。后续我们计划将知识图谱集成至远程Dify平台，这部分由另一位同学负责。值得一提的是，在我实现的LLM任务规划模块中，需要依赖该同学构建的行为认知图谱信息进行决策指导。



### 项目重难点：

**首先，最大的技术难点在于异构系统的整合与异步通信架构的设计。** 整个项目需要协调 QT（C++）、ROS（C++/Python）和基于 Web API 的 HTTP/JSON 服务这三种差异较大的技术栈。其中最关键的挑战是**必须确保主UI线程绝不阻塞**，任何耗时操作都不应影响界面响应，否则会导致界面卡顿甚至无响应。

具体来说，存在两方面的阻塞风险：

- **ROS 自身的阻塞机制**：例如 `ros::spin()` 在默认情况下会占用线程以处理消息；

- **网络请求的延迟**：尤其是调用大语言模型（LLM）的 HTTP 请求，受网络状况影响，属于高延迟操作。

为解决这些问题，我设计并实现了一套**彻底的多线程架构**：

1. **主UI线程**：仅处理界面渲染和用户交互事件，确保前端流畅运行；
2. **专用ROS通信线程**：将 ROS 的初始化、订阅和发布等功能封装于独立的 `RosThread` 中，使 `ros::spin()` 在后台持续运行；
3. **LLM网络请求线程**：使用单独的 Worker 线程处理所有网络操作，基于 `QNetworkAccessManager` 执行异步HTTP请求。

这三个线程之间的通信完全依赖 **Qt 的信号与槽机制**，并统一采用 `Qt::QueuedConnection` 方式进行连接，从而实现了线程安全的跨线程数据传递。这一架构不仅有效保障了UI的流畅性，也大幅降低了模块间的耦合度，提升了系统的可维护性与扩展性。

### 嵌入式的点在哪里

1. 这个项目的嵌入式特点主要体现在三个方面：

   简单来说，虽然现在是仿真，但整个系统从设计到实现都在为最终嵌入到实体机器人做准备。

   1. **架构设计**：采用了多线程和异步通信机制，专门避免阻塞主线程，这是嵌入式开发保证实时性的常用策略。
   2. **通信协议**：中间件支持UART/SPI等嵌入式常用协议，数据交换轻量高效，方便后续移植到真实嵌入式设备。
   3. **部署适配**：LLM和算法模块在设计时已考虑嵌入式部署需求，未来可平滑过渡到硬件在环测试，并支持模型量化等优化手段。

   

## 面向任务适应的机器人操作技能学习

为了实现国家自然科学基金的第三点要求：面向智能自主作业的迁移强化学习。进行了第三点项目的深入研究。简单来说就是人类学习抓取操作具备举一反三的能力，并把在其它任务中学会的技能应用于新人无形中，但是机器人学习一项新任务往往需要从头学习，所以我的研究是如何让机器人利用已有的任务经验加速新技能的学习过程。

基于这一目的提出了一种融合 LLM 与 DRL 的创新方法，实现了工业机器人历史技能的快速迁移，显著提升了新任务的学习效率。

首先：提出基于层次化语言理解的动态奖励架构，构建 LLaMA 微调框架，实现任务语义到奖励信号的映射，任务理解准确率提高34%；

这里的背景是机器人学习任务一般需要通过基于强化学习奖励函数进行不断地试错学习，以往的机器人任务学习往往采用人力手动设计奖励函数这是十分困难的耗时的。更先进的方法是采用LLLM 去生成奖励函数，而我的创新是使用自定义的 任务指令-》奖励组件数据集微调LLAMA大模型使其具备精准的奖励组件生成能力，实验证明经过我们微调后的LLM具备更准确的任务理解能力。

第二点主要是利用上一点生成的奖励组件，提示奖励生成LLM 更精准的生成奖励函数，并自带反馈机制实现动态奖励的生成与优化。

第三点：前两点都是在说一个机器人怎么学会自己学习一个任务通过制定较优的奖励函数进行引导。那么第三点就是说如何实现利用已有经验加速新任务的学习，主要是设计了一个迁移网络，提取原技能的特征融合到新技能中，实现跨任务的迁移，达到速度提升。

![image-20250822210213566](assets/image-20250822210213566.png)

虽然当前以仿真形式呈现，但整个系统的通信中间件、任务调度机制和硬件接口层均采用嵌入式设计中常见的低资源占用和实时性策略，为后续迁移到真实嵌入式平台（如ARM Cortex-A/M系列或ROS嵌入式设备）奠定基础。

难点：就是网络如何设计，如何实现。横向迁移。



虽然现在是在电脑上仿真验证，但这个方法特别适合将来放到真实的嵌入式机器人里用，因为：

第一，它不需要太强的算力，学习新任务时不需要重新训练，很适合嵌入式设备有限的计算资源；

第二，整个算法框架设计得很轻量，容易移植到实际的机器人控制器里；

第三，它能减少机器人的试错次数和学习时间，这在真实环境中特别重要，毕竟现实中不能让机器人一直瞎折腾。

简单来说，我们不仅让机器人变得更"聪明"，还让这个方法更容易在真实的嵌入式机器人上落地使用。





## 城市垃圾智能巡检单车

### 描述：

这个项目是大学期间申请的一个创新创业项目，整个项目是从硬件设计到软件实现都是由我和其他两个队友实现的，整个项目目的主要是想基于K210开发板和单车构建一个小范围的垃圾巡检系统，整个车通过固定路径或者遥控模式巡检城市垃圾，利用摄像头采集图片，并实时识别，利用GPS进行定位，当将测到垃圾时将整张图片包括垃圾类型、识别框、位置都记录下来然后保存到SD卡中。



### 分工：

我们的团队分工明确，配合也很默契。硬件部分由一位队友负责，包括车体的机械结构设计和驱动板、主控板的PCB绘制。还有一位队友专注于图像识别算法的开发，以及车体的实时运动控制。我主要负责软件方面，包括基于RT-Thread的系统架构设计、各模块间的通信协调，以及部分设备驱动的移植和适配工作。

### 技术要点详解



第一点：基于 RTT 与双缓机制开发图像处理架构，实现图像采集、目标检测与数据存储任务的并发执行，并支持道路巡航的实时识别；

主要有图像处理线程、GPS解析线程、蓝牙指令解析线程、SD卡写入线程。 图像的采集是在中断中执行的，并不能在中断进行识别检测，中断只负责请标志位，翻转双缓冲区，开启下一次DMA采集，发送信号量给图像识别线程。由图像识别线程接收到信号，进行识别，一旦是别到垃圾就上锁保护的写全局共享的检测结果然后解锁，发送有垃圾事件，。



第二点：基于 UART + FIFO 缓冲实现手机巡检指令实时解析与响应，并通过 RTT 事件机制触发小车运动模式切换与路径点动态设置；

主要实现的是手机蓝牙与单片机之间的通信，我设计了一个可靠的通信协议；用于解析不同的控制指令，比如是控制模式还是定点循迹模式，还是设置路径点。解析状态机根据指令设置响应的事件标志位灵活触发小车运动模式？（为什么设计这个，是会丢包吗）。

![image-20250822215045443](assets/image-20250822215045443.png)

是的，您理解得非常准确。设计自定义通信协议的核心原因，正是为了解决像您提到的这些简单协议所无法处理的可靠性问题。在您的项目中，设计一个可靠的协议是非常必要且正确的做法。

您提到的参考内容完美地解释了原因，在您的蓝牙通信场景中，这些问题具体表现为：

1. **抗干扰与数据校验（解决“能否信”）**：蓝牙通信环境可能存在干扰，导致数据位错误。简单的协议没有校验机制，单片机可能无法察觉，从而执行错误的指令。您的协议需要加入**校验位（如CRC或Checksum）**，用于验证数据的完整性，确保收到的数据是准确的。
2. **数据完整性（解决“是否全”）**：蓝牙传输的数据包可能因为信号不稳定等原因发生丢失。如果没有**数据包序号**，手机端发送了多条指令，但单片机可能只收到了其中一部分，它自己却无法发现指令已经丢失，从而导致任务执行出错。序号可以帮助双方确认有没有丢包。
3. **协议扩展性与指令管理（解决“怎么用”）**：
   - **指令类型**：需要一个字段来区分这是**运动控制指令**、**路径点设置指令**还是**系统查询指令**，而不是所有数据都混为一谈。
   - **数据长度**：如果指令所附带的参数长度是可变的（例如，后续可能需要传输更复杂的路径点信息），就必须有一个**长度字段**，这样接收方才能知道一个完整的数据包在哪里结束，从而正确解析，避免数据错乱。



### 问题

1. 基于 RTT 与双缓机制开发图像处理架构，实现图像采集、目标检测与数据存储任务的并发执行，并支持道路巡航的实时识别；

说说双缓机制  怎么并发执行，

由于图像采集是在DMA进行的单次采集（循环模式  单次模式），图像处理需要用到DMA采集的图像，如果只用一帧图像的话，可能发生图像正在使用的时候发生下一次DMA搬运污染图像数据，造成错帧的现象。我才用双缓就是AB 两帧 600*600的大小，在DMA中进行AB贞的翻转，假如是采集B帧完成，下一次存到A帧，发送信号量给图像处理线程，图像处理线程收到信号量获取B帧图像处理，下一次处理A帧，然后开启下一次的DMA传输，紧接着进行图像识别的操作，这样可以做到图像采集和目标检测的并行执行，大大提高CPU的利用率。  数据存储是接收目标检测识别到之后发送检测到的event标志位，然后再存储线程中存储图片，600X**600**X3 大小。 SPI速度

 ![image-20250830113732997](assets/image-20250830113732997.png)

2. 基于 UART + FIFO 缓冲实现手机巡检指令实时解析与响应，并通过 RTT 事件机制触发小车运动模式切换与路径点动态设置； （没有用驱动的fifo）

   手机端下载一个蓝牙调试助手，设置好对应的数据结构，然后发送，在k210的串口接收中断中接收数据，存储到fifo中，并发送信号量给数据解析线程（一个字节一个字节的收和sem,sem++,）在解析线程中通过状态解析机进行解析首先 帧头0xAA,命令字节cmd，数据长度lenth，根据数据位接收数据长度，进行crc16的高低位校验，帧尾检测0x55;

   然后根据命令字节判断是，还是使用预设路径还是蓝牙控制模式，也可以设计期望路径点。（double 经纬）

3. 基于 UART + UBlox 协议实现 CUAV Neo3 GPS 驱动，通过多线程状态机解析实现定位数据获取与解析，提供实时位置服务；

​	移植的 GPS自带的ublox协议，定义了数据的消息结构ublox 

​	固定   同步字符1 0xB5

​		  同步字符2 0x62

​		  消息类别

​		消息ID

​		载荷长度 legth

​		载荷数据 payload[UBLOX_MAX_PAYLOAD_LEN]

​		校验和A

​		校验和B    checksum校验 

初始化驱动函数： 1. 分配gps驱动结构体（uart设备句柄，解析线程，互斥锁信号量，接收缓冲区，解析状态机，gps数据） 2. 初始化为0 3. 查找uart设备 rt_device_find(name),4. 配置uart参数波特兰，校验位等（struct serial_configure config）rt_device_control 进行配置，5.打开uart设备中断接收模式，读写模式 rt_device_open() 6. 设置接受回调函数 6. 创建解析线程 7. */\* 发送配置命令：设置10Hz更新率 \*/*   rt_device_write(g_cuav_neo3_dev->uart_device, 0, *cmd*, *len*);

主要就是find 查找uart 设备，绑定，通过uart的接收中断读取gps数据，通过rt_device_write写命令配置gps.

 

数据解析线程：

1）uart中断回调：*/\* UART接收回调函数 - 基于RT-Thread FIFO机制 \*/*  */\* 通过信号量通知解析线程处理数据 \*/*

  rt_sem_release(gps_dev->data_sem);

2） */\* 等待UART数据到达信号量 \*/*

​    if (rt_sem_take(dev->data_sem, RT_WAITING_FOREVER) == RT_EOK) {

​      */\* 从UART FIFO读取数据    驱动中有fifo\*/*

​      read_len = rt_device_read(dev->uart_device, 0, rx_buffer, sizeof(rx_buffer));

​	        */\* 逐字节解析UBlox协议 \*/*

​        for (rt_size_t i = 0; i < read_len; i++) {

​          ublox_parse_byte(dev, rx_buffer[i]);-》     

3） */\* 校验成功，处理消息 \*/*

​        ublox_process_message(*dev*, &*dev*->current_msg);

​        }



​       }      



4. 基于 DMA + 完成量机制构建 SD/SPI/FATFS 阻塞式读写驱动，实现巡检照片高效写入至 SD 卡（单张图片写入耗时**125ms**）。

这部分也是移植的驱动 k210之前没有SDIO的控制器，只能采用SPI进行驱动写，其中SD的驱动主要是在SPI的xfer函数上进行进一步封装的。

DMA和完成量机制主要是等待SPI的DMA完成传输的一个标志。

（完成量和信号量的区别）

```c
rt_completion_wait(&bus->dma_completion, RT_WAITING_FOREVER);//阻塞等待中断回调唤醒线程（DMA 完成）；
```

drv_spi_xfer函数：

```c
static rt_uint32_t drv_spi_xfer(struct rt_spi_device *device, struct rt_spi_message *message)
```

1)获取总线bus,获取片选 cs，获取设备config,

2)如果需要片选，拉低

3)开始传输 ：初始化发送接收DMA通道，初始化完成量 rt_completion_init(&bus->dma_completion); *//置零*

​	如果是接收模式：分配接收DMA，

​	如果是发送模式：分配发送DMA， *为发送数据申请缓冲区；**将原始 uint8_t 数据写入 32-bit 对齐缓冲区。*

​	如果同时收发： 1.注册中断函数，2. 设置spi寄存器手发模式 3. 启动dma接收发送 

​	是能片选引脚开始

4）  阻塞等待DMA中断完成，rt_completion_wait(&bus->dma_completion, RT_WAITING_FOREVER);

5） *会将通道对应的中断注册项清除。* cs拉高，释放通道信号



msd _init过程：

*具体的初始化函数还是得调用  rt_device_init(dev);这个时候才会真正执行 rt_msd_init() 的全部初始化流程（例如识别 SD 卡、初始化 SPI 协议、建立扇区信息）。*

需要实现 init  open read write  close contal 函数，

​	1） **这个时候才会真正执行 rt_msd_init() 的全部初始化流程（例如识别 SD 卡、初始化 SPI 协议、建立扇区信息）。**

​	2）*//main函数中通过fprint  fget等函数本质上会调用 MSD驱动的的read函数，然后调用rt_msd_read->根据单块还是多块调用_read_block(),多块->read_blocks()*



如何计算的125ms， 单张图片大小600*600*3  sd的最高速度4M/S 大约写完一张要120ms左右。  rt_tick_get();



4. 设计基于 DMA/IDLE/环形缓冲区的串口不定长通信驱动，并构建协议解析状态机，通过CRC16校验保证指令数据的完整性；

空闲中断中可以计算空闲终端接受了一段数据，可以计算长度*计算DMA接收的数据长度*，*// 将接收的数据存入环形缓冲区*，*// 重启DMA接收*。



5. 采用 Event+MQ 异步驱动架构，结合原子操作多线程保护，实现双车协同指令与紧急事件响应（保证传球时间控制在2s内)；

​	有一杂项线程（图像第一  几件通信第二，杂项第三（检测车的紧急事件以及双车之间的协同指令，通过event事件，通过原子变量来修改全局的目标速度来响应紧急事件响应，MQ 消息队列主要用于记录蜂鸣器响应时长的，比如...圆环  三叉 十字检测到了就设计蜂鸣器响几秒）LCD显示线程 ）

​	2S就是一个事件范围，

结合原子操作多线程保护 这里解释封装了一个函数，在内部修改全局共享面量的时候关中断修改，之后开中断

### 第三点：

基于 UART + UBlox 协议实现 CUAV Neo3 GPS 驱动，通过多线程状态机解析实现定位数据获取与解析，提供实时位置服务；

移植协议，

 */\* 设置UART接收回调函数 \*/*

 */\* 创建解析线程 \*/*

![image-20250822222144960](assets/image-20250822222144960.png)



![image-20250822222108718](assets/image-20250822222108718.png)

### 第四点

基于 DMA + 完成量机制构建 SD/SPI/FATFS 阻塞式读写驱动，实现巡检照片高效写入至 SD 卡（单张图片写入耗时**125ms**）。

移植的，

这是最根本的硬件原因。许多微控制器（MCU），尤其是中低端的Cortex-M系列芯片，**并不自带SDIO控制器**。它们通常只提供标准的SPI外设。因此，使用SPI接口驱动SD卡是**唯一的选择**。相比之下，SDIO需要芯片有专用的SDIO硬件接口。



*/**

*主要包括* 

*1.头文件配置*

*2.数据结构定义*

*3.SPI配置函数*

*4.SPI数据传输函数*

*5.SPI初始化*

**/*

#include "drv_spi.h" //本驱动的头文件
#include <drv_io_config.h>  // IO引脚配置
#include <drivers/dev_spi.h>  //SPI设备定义
#include "dmalock.h"  //DMA通道锁管理
#include <sysctl.h> //系统控制相关
#include <gpiohs.h>  //高速GPIO操作
#include <string.h> 
#include "utils.h" //实用工具



*// SPI总线数据结构*

struct drv_spi_bus

{

  struct rt_spi_bus parent;   *// RT-Thread标准的SPI总线结构*

  spi_device_num_t spi_instance;  *// SPI实例编号(0,1,2,3)*

  dmac_channel_number_t dma_send_channel;*// 发送DMA通道*

  dmac_channel_number_t dma_recv_channel; *// 接收DMA通道*

  struct rt_completion dma_completion;  *// DMA完成信号量*

};

*/**

 *//开始DMA传输逻辑*

drv_spi_xfer()

{



 *//初始化完成量对象 dma_completion，用于等待 DMA 结束。*

*占用 DMA 接收通道；*

*占用 DMA 发送通道；*

if(*message*->send_buf && *message*->recv_buf)

​    {

​      */**

​      *设置 SPI 为发送 + 接收模式（全双工）；*

​      *同时注册 发送和接收 DMA 中断回调；*

​      *启用 SPI + DMA；*

​      *设置 DMA：*

​      *接收：SPI_DR ➜ rx_buff；*

​      *发送：tx_buff ➜ SPI_DR。*

​        *注册 DMA 接收中断回调；*

​        *设置 SPI 为 收发模式；*

​        *使能 DMA 发送 + 接收；*

​        *启用 SPI 模块。*

​      **/*

​      *//注册中断函数*

​      dmac_irq_register(bus->dma_recv_channel, dma_irq_callback, &bus->dma_completion, 1);

​      *//设置spi寄存器  收发模式*

​      __spi_set_tmod(bus->spi_instance, SPI_TMOD_TRANS_RECV);

​      *//启 DMA 接收 + DMA 发送（位0 + 位1）。*

​      spi_instance[bus->spi_instance]->dmacr = 0x3;  *// 寄存器/位  dmacr = 3 含义  使能DMA发送和接收*

​      *//启用 SPI 模块。*

}



​    rt_completion_wait(&bus->dma_completion, RT_WAITING_FOREVER);*//阻塞等待中断回调唤醒线程（DMA 完成）；*

​    *//清理&后处理  注销中断。*

​    */**

​    *收完或发完后，注销中断回调，避免残留回调影响后续；*

​    *dmac_irq_unregister(channel) 会将通道对应的中断注*

## SPI 驱动  

重要的是xfer函数

初始化信息 比如完成量，舒适DMA通道，临时rxbuff等

1. 根据接收还是发送分配DMA通道， 
2. 根据收发 还是同时收发  注册dma中断函数， 设置SPI的寄存器收发模式， 启动dma收发模式设置寄存器dmacr, 启用SPI模块设置寄存器 ssienr
3. 启动传输，拉低片选
4. 等待rt_completion_wait(); dma中断完成会调用rt_completion_down，唤醒等待程序。
5. 注销终中断调函数中
6. 等待FIFO清空，*通常用于 SPI 主机在关闭片选信号前 清空发送缓存，避免截断数据。*
7. *取消片选 ser 失能；禁用 SPI 控制器 ssiner 禁止*
8. *把 rx_buff 中数据拷贝回用户 buffer*，
9. 清理资源   *释放锁；释放 malloc 分配的临时 buffer*





### SPI IIC的区别

![image-20250826215715047](assets/image-20250826215715047.png)

![image-20250826215742178](assets/image-20250826215742178.png)

![image-20250826225213801](assets/image-20250826225213801.png)

🧠也就是说  xfer控制的发送和接收是对dr[36]操作的 数据寄存器，是在 地址和数据总线上的。 可以通过读取“数据寄存器 DR”，可以获取接收缓冲区中的内容。  通过写 SPI 的“数据寄存器 DR”把数据填充到发送 F 缓冲区中，

```c
            /*设置 DMA 接收：SPI 接收寄存器 ➜ rx_buff；设置 DMA 发送：tx_buff ➜ SPI 发送寄存器。*/  
            //    /* SPI Data Register 0-36    (0x60 -- 0xec)      volatile uint32_t dr[36]; */
            //通道   源地址  目的地址
            /*
            void dmac_set_single_mode(
                dmac_channel_number_t channel,       // DMA 通道号
                void *src,                           // 源地址
                void *dst,                           // 目的地址
                dmac_addr_increment_t src_inc,      // 源地址是否自增
                dmac_addr_increment_t dst_inc,      // 目的地址是否自增
                dmac_msize_t dmac_msize,            // 总线突发大小（一次搬几个）
                dmac_transfer_width_t trans_width,  // 传输单位宽度（字节/半字/字）
                size_t block_size                   // 总传输数量（单位个数，不是字节）
            );
            */
            dmac_set_single_mode(bus->dma_recv_channel, (void *)(&spi_instance[bus->spi_instance]->dr[0]), rx_buff, DMAC_ADDR_NOCHANGE, DMAC_ADDR_INCREMENT,
                           DMAC_MSIZE_1, DMAC_TRANS_WIDTH_32, message->length);
```

![](assets/image-20250826215756016.png)

![image-20250826220000957](assets/image-20250826220000957.png)

可以是半双工   

​	只用MOSI ：发送时 地址和数据总线将数据写到发送缓冲区-》移位寄存器-》发送

​				接受时 从MOSI接收-》数据经过移位寄存器-》接收缓冲区。

![image-20250826220646211](assets/image-20250826220646211.png)

![image-20250826220726309](assets/image-20250826220726309.png)

可能是奇数边沿MOSI  MISO 寄存器变化，偶数边沿采样

![image-20250826221024195](assets/image-20250826221024195.png)

![image-20250826221202296](assets/image-20250826221202296.png)



![image-20250826221749633](assets/image-20250826221749633.png)



### SPI config  配置都配置什么（SPI_CR0寄存器）

​	片选



 	 时钟（CPOL）  相位(CPHA)  

​	工作模式（0~3）

​	 数据位宽

* 设置SPI时钟频率*波特率

![image-20250826224515803](assets/image-20250826224515803.png)



![image-20250826224556802](assets/image-20250826224556802.png)

![image-20250826224626963](assets/image-20250826224626963.png)



#### 状态寄存器

 通过读取状态寄存器判断接受的状态：

![image-20250826224728948](assets/image-20250826224728948.png)



### 数据寄存器

![image-20250826224837244](assets/image-20250826224837244.png)





#### 整个过程

主要遵循发送一位 接受一位； 整个都是SPI主机的图，软件向dr中写入一个数据，等待MOSI发送完TXE，然后接受等待RXNE=1从SPI_DR中读取数据。等待MOSI发送完TXE，然后接受等待RXNE=1从SPI_DR中读取数据。

![image-20250826230133944](assets/image-20250826230133944.png)



主模式收发流程及事件说明如下：

1. 控制 NSS 信号线，产生起始信号 (图中没有画出)；
2. 把要发送的数据写入到“数据寄存器 DR”中，该数据会被存储到发送缓冲区；
3. 通讯开始，SCK 时钟开始运行。MOSI 把发送缓冲区中的数据一位一位地传输出去；MISO则把数据一位一位地存储进接收缓冲 区中

(4) 当发送完一帧数据的时候，“状态寄存器 SR”中的“TXE 标志位”会被置 1，表示传输完一帧，发送缓冲区已空；类似地，当接收完一帧数据的时候，“RXNE 标志位”会被置 1， 表示传输完一帧，接收缓冲区非空；

(5) 等待到“TXE 标志位”为 1 时，若还要继续发送数据，则再次往“数据寄存器 DR”写入数据即可；等待到“RXNE 标志位”为 1 时， 通过读取“数据寄存器 DR”可以获取接收缓冲区中的内容。

假如我们使能了 TXE 或 RXNE 中断，TXE 或 RXNE 置 1 时会产生 SPI 中断信号，进入同一个中断服务函数， 到 SPI 中断服务程序后，可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用 DMA 方式来收发“数据寄存器 DR”中的数据。



### 1.3. 软件SPI与硬件SPI的区别

1.3.1. 软件SPI

软件SPI需要用IO口模拟时序，这个模拟过程全部由CPU完成，为了能稳定的存入数据，可能插入软件延时，这个时间在读取数据量小的情况下不明显， 但是基本上你在读取过程中其他非中断、非异常程序是无法得到执行的。

1.3.2. 硬件SPI

硬件SPI数据存储过程是不需要CPU参与的，程序中配置好SPI的访问时序，开启中断，CPU就可以在中断函数中搬移数据，省下了软件模拟IO的存取时间。 这一节介绍的内容就是硬件SPI。

当然，不能认为硬件SPI速度快，在做项目时就一定要用它，这需要根据实际情况而定。



## I2C协议

![image-20250826230830085](assets/image-20250826230830085.png)



![image-20250826231107803](assets/image-20250826231107803.png)

同步串行半双工 

![image-20250826231416803](assets/image-20250826231416803.png)

![image-20250826231510705](assets/image-20250826231510705.png)



挂在在总线上的设备都有自己唯一的ID

![image-20250826231604527](assets/image-20250826231604527.png)

1. 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。
2. 一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。
3. 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。
4. 总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。
5. 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。
6. 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式。
7. 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制。



![image-20250826232000793](assets/image-20250826232000793.png)



!![image-20250826232411953](assets/image-20250826232411953.png)



字节必须是8位  必须是MSB（高位先发）应答信号低电平。

![image-20250826232700275](assets/image-20250826232700275.png)



![image-20250826232719446](assets/image-20250826232719446.png)

#### 地址 

起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在I2C 总线上， 每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了， 没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7 位或 10 位。

#### 读写

在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。

从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收到应答信号后，主机才能继续发送或接收数据。



#### 写数据

**写数据** 若配置的方向传输位为“写数据”方向，即第一幅图的情况，广播完地址，接收到应答信号后， 主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位，主机每发送完一个字节数据， 都要等待从机的应答信号 (ACK)，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。 当数据传输结束时，主机向从机发送一个停止传输信号 (P)，表示不再传输数据。



### 读数据

若配置的方向传输位为“读数据”方向，即第二幅图的情况，广播完地址，接收到应答信号后，从机开始向主机返回数据 (DATA)， 数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)，重复这个过程， 可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号 (NACK)，则从机自动停止数据传输。

![image-20250826233555084](assets/image-20250826233555084.png)

![image-20250826233601611](assets/image-20250826233601611.png)

![image-20250826233648547](assets/image-20250826233648547.png)



STM32 的 I2C 外设可用作通讯的主机及从机，支持 100Kbit/s 和 400Kbit/s 的速率，支持 7 位、10位设备地址，支持 DMA 数据传输， 并具有数据校验功能。它的 I2C 外设还支持 SMBus2.0 协议，SMBus 协议与 I2C 类似，主要应用于笔记本电脑的电池管理中，本教程不展开， 感兴趣的读者可参考《SMBus20》文档了解。

![image-20250826233749168](assets/image-20250826233749168.png)















## CAN





## USB





## uart（RS-232 RS-485 RS-422）

串口只是一个泛称，以上几种都遵循雷迪的通信时需协议，被称为串口。

![image-20250826214534828](assets/image-20250826214534828.png)

![image-20250826214558112](assets/image-20250826214558112.png)

![image-20250826214457873](assets/image-20250826214457873.png)

![image-20250826214809575](assets/image-20250826214809575.png)

![image-20250826214847826](assets/image-20250826214847826.png)

![image-20250827094744015](assets/image-20250827094744015.png)

![image-20250827094932913](assets/image-20250827094932913.png)

![image-20250827095138247](assets/image-20250827095138247.png)





RS485(半双工)



工控-

![image-20250827095305374](assets/image-20250827095305374.png)

![image-20250827095318149](assets/image-20250827095318149.png)

![image-20250827095529946](assets/image-20250827095529946.png)

![image-20250827095845870](assets/image-20250827095845870.png)

![image-20250827095856188](assets/image-20250827095856188.png)

![image-20250827100113304](assets/image-20250827100113304.png)

![image-20250827100256853](assets/image-20250827100256853.png)

## CAN

![image-20250827100605784](assets/image-20250827100605784.png)

![image-20250827100741518](assets/image-20250827100741518.png)

 

![image-20250827100942947](assets/image-20250827100942947.png)

![image-20250827101129907](assets/image-20250827101129907.png)

IIC是由主机发送开始信号才能进行通信



Can 每一个设备都可以主动发送数据

![image-20250827101333637](assets/image-20250827101333637.png)

### 物理层

![image-20250827101438054](assets/image-20250827101438054.png)

显性电平0

![image-20250827101534877](assets/image-20250827101534877.png)

![image-20250827101651188](assets/image-20250827101651188.png)

![image-20250827101714649](assets/image-20250827101714649.png)

![image-20250827101732702](assets/image-20250827101732702.png)

### 协议层

一帧一帧的，五种类型帧，

数据帧：发送单元向接受单元发送数据

遥控帧： 用于接收方向具有相同ID的发送方发送请求数据的帧（告诉别人你可以发了）

错误帧：检测出错误想起他单元发送错误帧（告诉别人出错了）

过载帧：接受单元通知其尚未做好接受准备的帧（告诉别人你发的太快了）

间隔帧：数据帧  遥控帧与前面分离开来的帧

​    

![image-20250827102525538](assets/image-20250827102525538.png)

#### 数据帧

有七段组成  标准真和扩展帧

 ![image-20250827102728815](assets/image-20250827102728815.png)

帧起始：0 显性电平（表示数据帧开始）

仲裁段： ID 表示帧优先级的段 11bit

​		RTR 远程发送请求位   0 ： 数据帧   1：遥控帧 （区别在于有没有数据）

![image-20250827103121787](assets/image-20250827103121787.png)

控制段： DLC ：表示数据的字节数 数据长度编码

​		IDE：扩展标识符位（ 标准还是扩展帧）

​		R0: 

数据段： 0~64bit  (0~8字节)

![image-20250827103542336](assets/image-20250827103542336.png)

CRC：15bit校验  帧传输错误

ACK ：确认正常接收的段、（发送时是1 ，当接收到了设备会置0）

真结束：7个隐形型号

![image-20250827104424336](assets/image-20250827104424336.png)

#### 位时序

位同步机制  实现对电平的正确采样。（没有时钟  只有差分）

  ![image-20250827110221163](assets/image-20250827110221163.png)

![image-20250827110345683](assets/image-20250827110345683.png)

![image-20250827110501897](assets/image-20250827110501897.png)



 

![image-20250827105326189](assets/image-20250827105326189.png)

![image-20250827105431032](assets/image-20250827105431032.png)

![image-20250827105448870](assets/image-20250827105448870.png)

![image-20250827105527158](assets/image-20250827105527158.png)

![image-20250827105753408](assets/image-20250827105753408.png)

![image-20250827105822991](assets/image-20250827105822991.png)

![image-20250827111232059](assets/image-20250827111232059.png)

## Git命令

![image-20250827112052945](assets/image-20250827112052945.png)

![image-20250827112147475](assets/image-20250827112147475.png)

![image-20250827112221314](assets/image-20250827112221314.png)

![image-20250827112228211](assets/image-20250827112228211.png)

![image-20250827112324988](assets/image-20250827112324988.png)

![image-20250827112434225](assets/image-20250827112434225.png) 

![image-20250827113432731](assets/image-20250827113432731.png)

![image-20250827113549222](assets/image-20250827113549222.png)

#### 1. git fetch

**有什么用？**

`git fetch` 的核心作用是：**从远程仓库下载最新的提交历史、分支和标签到你的本地仓库，但不会自动合并或修改你当前的工作。**

你可以把它想象成 **“检查远程服务器上有什么更新”** 的操作。

- **它下载什么？** 它会获取所有你本地还没有的远程分支（比如 `origin/main`, `origin/feature`）的最新提交和其他数据。
- **它改变什么？** 它**不会**改变你本地的任何文件、你的当前分支（如 `main`）或你的工作目录。它只是更新了本地的“远程跟踪分支”（如 `origin/main`），让你能看到远程仓库的最新状态。

**为什么需要它？**
在团队协作中，其他同事可能已经向远程仓库推送了他们的代码。在你开始工作之前或之后，使用 `git fetch` 可以让你了解远程仓库的最新情况，而不会影响你手头正在做的工作。

**常用命令：**

- `git fetch`：获取所有远程仓库的更新。
- `git fetch origin`：获取名为 `origin` 的远程仓库的更新。
- `git fetch origin main`：只获取远程 `origin` 的 `main` 分支的更新。





1. **这时，你该用 `git fetch` 了**：
   你想知道：“图书馆的书有没有什么新变化？我的同事有没有提交新内容？”
   于是你执行了 `git fetch`。这个命令就像是：**你派了一个秘书跑去图书馆，把最新的目录和更新了的章节复印回来，放在你书桌的另一个文件夹里（这个文件夹叫 `origin/main`），然后告诉你：“老板，图书馆的书更新了，这是最新情况。”**

   **重点：**

   - **秘书没有动你正在写的稿子！** 你的**章节3**还好好的在那儿。
   - 秘书只是把图书馆的新内容**报告**给了你。你现在**知道**了图书馆的新版本，但还没有把它和你手头的工作合并。

**所以，`git fetch` 的作用就是：安全地、不打扰你工作地，去检查远程仓库有什么新东西。它只“看”不“改”。**





###  3. git rebase

**有什么用？**

`git rebase` 的核心作用是：**重新设置你当前分支的“基址”。** 它是一种整合来自不同分支的修改的方法，通常用于让提交历史变得更加清晰线性。

它的工作方式可以理解为 **“把我的修改接到别人最新工作的后面”**。

假设你的提交历史是这样的（`main` 是主分支，`feature` 是你的特性分支）：

text

```
      A---B---C feature
     /
D---E---F---G main
```

- **如果你在 `feature` 分支上执行 `git rebase main`：**
  1. Git 会首先找到 `feature` 和 `main` 分支的共同祖先（提交 E）。
  2. 然后临时保存你的特性分支上的所有修改（A, B, C）。
  3. 将 `feature` 分支的指针快速移动到 `main` 分支的最新提交（G）上。
  4. 最后，把你保存的修改（A, B, C）依次在 G 之后重新应用一遍。

最终的历史会变成一条干净的直线：

text

```
              A'--B'--C' feature
             /
D---E---F---G main
```

**为什么需要它？**

- **更清晰的历史：** 避免了不必要的合并提交（merge commit），使项目历史看起来像按时间顺序直线发展的，更容易阅读和理解。
- **在合并前更新分支：** 在将你的分支合并回主分支之前，先变基到最新的主分支上，可以确保你的代码是基于最新的代码开发的，减少冲突的可能性。

**注意：** Rebase 会重写提交历史，因此**绝对不要**对已经推送到远程仓库并与他人共享的分支执行变基操作，这会给协作者带来极大的混乱。

![image-20250827141829476](assets/image-20250827141829476.png)

![image-20250827141931179](assets/image-20250827141931179.png)





![image-20250827142057446](assets/image-20250827142057446.png)

```c
# 1. 添加所有更改到暂存区
git add .

# 2. 创建提交
git commit -m "修复了登录页面的按钮样式"

# 3. 先检查一下远程仓库有没有别人推送的新代码（只查看，不自动合并）
git fetch

# 4. 查看状态，这会告诉你当前分支和远程分支的对比情况
git status

# 根据 `git status` 的提示：
# 如果显示 `Your branch is ahead of 'origin/main' by 1 commit.`，说明只有你一个人有提交，可以直接push。
# 如果显示 `Your branch and 'origin/main' have diverged...`，说明远程也有新提交，你需要整合。

# 5. 如果远程有更新，就用rebase进行整合
git rebase origin/main  # 或者直接用 `git pull --rebase`

# 6. 确认无误后，推送到远程
git push
```

![image-20250827142343803](assets/image-20250827142343803.png)





# 北方华创

## 工作要求：

![image-20250828100428601](assets/image-20250828100428601.png)

看着是相中了QT 功能；



**描述：**本项目基于 ROS+QT+LLM 开发一套智能机器人仿真平台，实现自然语言文本→LLM任务规划→机器人动作执行闭环控制。

**技术栈：UR3、ROS1（C++/CMake/Python）、QT（Network/Json/Thread）、Dify（Docker）、LLM、Gazebo**

- 开发基于 Qt5 的智能机器人交互系统，集成 LLM 任务规划、指令下发、日志存储与实时监控等功能，实现高效的人机协同作业；
- 基于Dify+LLM构建语义解析引擎，实现非结构化自然语言指令到机械臂运动序列的精准转换，组装任务解析准确率达到 91.3%；
- 开发智能语言控制中间件，通过对动作序列的解析和分发，实现其到 ROS 指令的实时转换，并具备自动执行和异常处理等功能。





## 自我介绍



面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。

我的技术方向主要集中在嵌入式系统和软件开发方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议，做过基于状态机的解析机制；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率。此外在面向任务适应的机器人操作技能学习项目中，构建了一个横向多层特征连接与纵向动态可扩展的

通过项目实践，我积累了linux下项目开发经验，Qt作交互界面，多线程处理以及数据交互等关键技术，能够独立完成功能设计和测试工作。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持程序的开发与调试。期待能加入贵公司，为医疗设备相关软件的开发贡献自己的力量。

































2.北方华创。月18K（基本工资15.6K，绩效5.4K）。年终奖2~4个月工资。算下来一年25W~28W。有大兴户口，没有事业编制。宿舍四人间。hr说项目紧才加班，网上说加班多，有加班费。北方华创也算是国内半导体行业的龙头了。

















## ❓ 为什么投华创？

回答要点：

1. **行业地位**：北方华创是国内头部半导体设备公司，行业认可度高，发展前景大。
2. **岗位契合**：岗位和你的技能背景高度匹配（控制软件、C++/Qt、RTOS/ROS 等）。
3. **成长机会**：华创在半导体装备国产化进程中承担重要角色，你能接触最前沿的技术和项目。
4. **价值认同**：你希望通过软件研发参与到“卡脖子”关键设备国产化进程。

✅ 示例答法：

> 我投递华创主要有两个原因。第一，华创是国内领先的半导体装备企业，在刻蚀机、清洗机等领域处于行业前沿，代表着国产设备突破“卡脖子”环节的核心力量。我希望能在这样的平台中发挥所长。第二，岗位要求和我的背景非常契合，比如我在研究中做过机器人控制、RTOS 驱动和 ROS+Qt 的工业软件开发，这些都和机台控制软件研发有相通之处。我希望在华创的平台上进一步提升工程能力，也为国产设备的发展贡献力量。

华创是国内领先的半导体设备企业，在行业里有很强的技术实力。第二，岗位要求和我的背景非常契合，比如我在研究中做过机器人控制， ROS+Qt 的工业软件开发，这些都和机台控制软件研发有相通之处。我希望在华创的平台上进一步提升工程能力，也为国产设备的发展贡献力量。



## ❓ 如何了解到华创的？

回答要点：

1. **信息渠道**（要真实，比如）：
   - 学校宣讲会 / 校招官网 / BOSS直聘 / 牛客网 / 学长推荐 / 实习经历。
   - 结合你科研方向（机器人、工业控制），了解到华创在半导体设备领域的软件需求。
2. **兴趣驱动**：你不是随便海投，而是有意识关注国产半导体设备企业。

✅ 示例答法：

> 我最初是通过学校的宣讲会和官方校招信息了解到华创的，后来又结合学长的推荐和一些行业报道，对公司有了更深入的认识。我了解到华创在半导体设备国产化中处于领军位置，特别是在等离子刻蚀、PVD、CVD 等设备软件研发上有很高的技术要求。这让我觉得，自己在机器人和工业控制方向积累的经验，正好可以和华创的业务产生结合点，所以选择投递。

我主要是通过学校的宣讲会和校招信息了解到华创的，也结合行业报道进一步了解了公司的发展情况。



## 业务问题

**业务问题：**

你用过git进行，知道git merge和git rebase的区别吗？

C++多态如何实现？

对包含有一个int a的类或者类实例进行sizeof（），获取到的大小是多少，如果类中有虚函数呢？虚函数指针和虚函数表存储在哪里？

TCP的全连接队列和半连接队列、TCP的TIME-WAIT状态是什么？

用过哪些STL容器，分别用来存储什么类型的数据？

vector持续push_back操作会导致什么？扩容的过程是什么？

unordered_map在使用时可能发生什么问题？哈希冲突的两种解决方法？

map是用红黑树存储数据，数据查找的时间复杂度是什么？

c语言定义一个char类型的字符串数组，大小为20，使用strcopy往这个数组中拷贝字符串时需要注意什么？



##  反问

最后我想再请教一下：咱们部门目前在软件方面的主要业务方向是什么？另外，对于新人是否会有系统的培养计划或导师带教机制呢？





我想再确认一下，咱们软件工程师的工作主要是集中在北京总部吗？另外，接下来的招聘流程大概是怎样安排的呢？





![image-20250902102057258](assets/image-20250902102057258.png)







## ✅ HR 问题答法参考

1. **家庭情况**

> 我的家人都非常支持我在北京发展，所以工作上没有后顾之忧。

1. **个人单身状况**

> 目前是单身，精力主要放在工作和提升自己上。

1. **接受什么样的工作强度**

> 我能接受正常的加班或者项目节点需要的投入，只要合理安排，保证效率和质量没有问题。

1. **职业规划**

> 短期希望尽快适应岗位，积累设备软件研发的经验；长期希望能在半导体装备软件方向深入，成长为独立负责模块的骨干工程师。

1. **期望薪资**

> 我主要看重岗位发展和学习机会，薪资希望能按照公司校招的统一标准来。

1. **工作地点**

> 北京完全没有问题，我也希望能在北京这样的研发氛围里长期发展。

1. **有没有拿到 offer**

> 目前还在面试阶段，华创是我非常看重的机会，所以我希望能优先考虑。

1. **找工作主要看重那几点**

> 我主要看重三个方面：岗位和自身背景的匹配度、公司的行业地位与发展前景，以及个人成长的空间。

1. **为什么投华创**

> 华创是国内领先的半导体设备企业，在行业里有很强的技术实力。岗位和我的研究背景（控制软件、工业方向）很契合，所以希望能加入。

1. **如何了解到华创的**

> 一方面是通过学校宣讲和校招信息，另一方面也通过行业报道和学长的推荐，对公司有了进一步了解。
>
> 





# 汇顶科技

## linux的启动流程

**核心就是：固件 -> 引导 -> 内核 -> systemd -> 登录**

```
问题 31：linux 启动流程？
阶段 1: Bootloader (引导加载程序)
这是启动的序幕，完全在操作系统之外运行。

硬件初始化：CPU 上电后，从预设地址（通常是芯片的 ROM）执行第一段代码，称为 BootROM。它初始化最基础的硬件（如时钟、内存控制器），然后加载下一阶段的引导程序。

Primary Bootloader：例如 U-Boot、GRUB、或芯片厂商提供的工具。它的核心职责是：

初始化更多硬件：如存储设备（eMMC、SD卡）、网络（用于网络启动）、显示屏等。
定位内核映像：从存储设备或网络上找到 Linux 内核镜像（zImage、uImage或 Image）和可选的初始内存磁盘（initramfs或initrd）。

加载到内存：将内核和 initramfs加载到指定的物理内存地址。

传递参数：准备并传递启动参数给内核，最重要的是 设备树（Device Tree Blob, DTB） 的地址（在 ARM 等架构上）或命令行参数（cmdline）。

跳转到内核：最终将 CPU 的执行权交给内核的入口点。

阶段 2: 内核初始化阶段

内核开始执行，但此时还在解压和进行最基础的初始化。
内核解压与入口：如果内核是压缩过的（如 zImage），首先会运行一段小代码进行自解压，然后跳转到真正的内核入口函数（通常是 _start或 stext）。
架构相关初始化：在内核入口函数中，进行非常底层的 CPU 和平台相关初始化：
设置异常向量表。
初始化 MMU（内存管理单元），开启虚拟内存。这是一个关键转折点，之后内核将运行在虚拟地址空间。
检测 CPU 拓扑结构。
通用内核初始化 (start_kernel)：这是 Linux 内核初始化的主函数，它初始化了几乎所有内核子系统：
设置陷阱（Trap）、中断（IRQ）。
初始化调度器：为初始线程（0号进程，即 idle进程）初始化调度器。
初始化内存管理（mm_init）：建立完整的内存管理数据结构，伙伴系统开始工作。•初始化内核的 initramfs：如果存在，将其解压并准备好。
初始化 VFS（虚拟文件系统）：为后续挂载真实文件系统做准备。
初始化设备模型（driver_init）：建立总线、设备、驱动的模型框架。
解析启动参数：处理从 Bootloader 传来的 cmdline。
初始化早期外设和中断。
创建第一个用户态进程：在 start_kernel的最后，会调用 rest_init函数，该函数会创建两个内核线程： 
kernel_init：1号进程（init进程）的雏形，它是所有用户进程的祖先。
kthreadd：2号进程，负责调度和创建其他内核工作线程。

阶段 3: 内核启动阶段 (kernel_init)
这个阶段由 kernel_init内核线程执行，它负责完成启动的“临门一脚”。
等待kthreadd初始化完成。
加载并挂载 initramfs：如果使用了 initramfs，内核会将其解压并挂载为临时的根文件系统。initramfs包含一个精简的用户空间，包含了挂载真实根文件系统所必需的工具和驱动（如加密模块、RAID 驱动、非标准文件系统驱动等）。
执行 initramfs中的 /init：initramfs中的第一个程序通常是 /init（一个脚本或可执行文件）。它负责：
加载必要的内核模块（驱动）。
识别真正的根文件系统设备（如 /dev/mmcblk0p2）。
可能涉及解密、逻辑卷管理（LVM）等复杂操作。
最后，将根文件系统切换（pivot_root） 到真实的根文件系统上。
执行真实的 /sbin/init：在真实的根文件系统被挂载后，kernel_init会尝试执行根文件系统上的 /sbin/init（这是传统的 1 号进程）。此时，内核的启动任务完成，控制权完全交给用户空间。


阶段 4: 用户空间初始化 (Systemd)
这是由 /sbin/init（通常是 systemd）主导的阶段。
Systemd (现代主流)：
解析配置：读取 /etc/systemd/system和 /lib/systemd/system等目录下的单元文件（.service, .target等）。
启动目标（Target）：默认会进入 default.target（通常链接到 graphical.target或 multi-user.target）。
并行启动服务：根据依赖关系，尽可能并行地启动所有需要的系统服务（如 sshd, dbus, getty等）。
资源管理：通过 cgroups管理进程组资源。
阶段 5: 登录界面
系统初始化的最后一步是启动登录管理器。
Getty 或 Display Manager：
在文本模式下，init会启动多个 getty进程，监听 tty1-tty6，显示 login:提示符。
在图形模式下，会启动显

```





```
阶段一：BIOS/UEFI 阶段（硬件初始化）
1. 加电自检：计算机通电后，主板上的固件（BIOS 或现代的 UEFI）开始运行。它检测和初始化关键硬件，如 CPU、内存、磁盘、显卡等。
2. 寻找引导设备：POST 完成后，固件按照预设的启动顺序（如：硬盘、U盘、光驱、网络）寻找可引导的设备。
3.读取主引导记录 (MBR) 或 EFI 分区：
		BIOS+MBR：从启动设备的第一个扇区（512字节）读取 MBR。MBR 包含一小段引导代码（446字		节）和分区表。
        UEFI+GPT：UEFI 固件直接从硬盘上的 EFI 系统分区 (ESP) 中查找并执行已注册的引导程序应		  用程序（如 grubx64.efi）。这种方式更现代、更强大。
阶段二：引导程序阶段（GRUB2）
1. 引导加载程序执行
	显示一个启动菜单，让用户选择要启动的操作系统或内核版本。
	加载所选版本的 Linux 内核镜像（/boot/vmlinuz-xxx）到内存中。
	同时，将初始 RAM 磁盘镜像 (initramfs/initrd) 加载到内存。这个镜像包含了启动早期所必需的	核心驱动（如文件系统、磁盘控制器驱动）和工具。
阶段三：内核初始化阶段
1.内核解压与初始化
	内核被加载到内存后，首先进行自解压，然后开始初始化。
	关键任务：
    初始化 CPU、内存管理等核心子系统。
	设置虚拟地址空间，为进程调度做准备。
	注意：此时内核还无法访问真正的根文件系统，因为磁盘控制器和文件系统的驱动可能还在 initramfs 		里。
2.挂载 initramfs 并执行 /init
	动作：内核将 initramfs 解压为一个临时的根文件系统（rootfs）并挂载它。
阶段四：系统初始化与用户空间启动 (systemd 或 SysV init)
1.启动 init 进程 (PID 1)
动作：内核在挂载根文件系统后，会尝试执行第一个用户空间进程，它的进程号永远是 1。
2.systemd 的工作流程（现代主流）
读取 /etc/systemd/system/default.target，确定系统要进入的运行级别（target），常见的有： 多用户命令行模式。图形界面模式。
阶段五：登录界面

```

![image-20250904145443619](assets/image-20250904145443619.png)

![image-20250904145732006](assets/image-20250904145732006.png)

![image-20250904152521333](assets/image-20250904152521333.png)

![image-20250904152758758](assets/image-20250904152758758.png)



1. 问了面试题
2. 问了编译器 gcc along 还用过其他编译器吗
3. qt 的问题  
4. 编程代码中的问题   （int）num + 0.5  强转
5. QT的qthread 直接调用run不会出现问题吗
6. 





# 开立医疗面经





掌握面向对象设计方法和常见的设计模式。









2. 多态的实现原理

   ```
   静态多态： 函数重载，编译期就确定
   
   动态多态： 虚函数，vitural,运行时确定，
   实现方式：
   	类中存在虚函数时，编译器会为类生成一张 虚函数表（vtable）。
   	每个对象中存放一个指向该表的 虚函数指针（vptr）。
   	调用虚函数时，通过 vptr → vtable → 函数地址 来动态绑定。
   ```

   

3. 虚函数表存放在哪里

​	

```
虚函数表（vtable） 是编译器为类生成的，存放在 只读数据段（.rodata） 或 全局区。

每个类只有一张 vtable（继承链情况除外），不会为每个对象都生成。
```



2. 虚函数指针存放在哪里

   ```
   每个对象实例内部，会额外存放一个隐藏的指针成员，即 vptr。
   
   通常位于对象内存布局的起始位置（具体由编译器实现）。
   
   当对象构造时，编译器在构造函数里负责初始化 vptr 指向正确的 vtable。
   ```

   

3. 讲一讲内存的分布

   注意代码段中存放程序指令  常量字符串 和虚函数表

```
内核保留区
--------------------
栈 (stack)       // 局部变量、函数调用栈帧
--------------------
堆 (heap)        // new / malloc 分配的动态内存
--------------------
BSS 段           // 未初始化的全局变量、静态变量
--------------------
数据段 (data)    // 已初始化的全局变量、静态变量
--------------------
代码段 (text)    // 程序指令、常量字符串、虚函数表

```



2. 堆和栈的区别

   ![image-20250905171906708](assets/image-20250905171906708.png)

3. 手撕一个类，完成其拷贝构造函数和

   ```c++
   #include<iostream>
   class Mystring
   {
       private :
       	char * data;
       public:
       //构造函数
       Mystring(const char* s="")
       {
           data=new  char[strlen(s)+1] ; //strlen()不计算\0  申请的时候加上
           strcpy(data,s); // 字符串的赋值只能用strcpy(目的，源)
       }
       //拷贝构造 深拷贝
       Mystring (const Mystring &other)
       {
           data= new char[strlen(other.data)+1];
           strcpy(data,other.data);
       }
       //析构函数
       ~Mystring()
       {
           delete[] data;
       }
   }
   ```

   

4. 为什么要写拷贝构造？知道深拷贝和浅拷贝的区别吗？



```c
默认的拷贝构造函数是浅拷贝（）逐字节复制，导致多个对象指向同一块堆内存，析构时会出现 doubule free;

深拷贝，重新开辟一块堆内存，把内容复制过去，保证对象之间的独立性。
    
    写拷贝构造的原因：
    管理资源： 堆内存，文件句柄
    避免浅拷贝引起的选空指针、内存错误。
```



2. 讲一讲智能指针？



```c
智能指针是一个类模板，封装了原始指针，实现自动管理内存：
    出作用域时，自动调用 delete

	避免手动释放带来的内存泄漏/悬空指针
常见智能指针：
std::unique_ptr：独占式，禁止拷贝，只能转移（move）
std::shared_ptr：引用计数型，多个指针共享同一资源
std::weak_ptr：弱引用，不增加计数，用来解决循环引用    
```



2. share_ptr的原理？

![image-20250905173844925](assets/image-20250905173844925.png)

2. 计数器在哪里？（堆上，每个share对象会有指针指向这块内存）

![image-20250905173907323](assets/image-20250905173907323.png)

2. 那什么时候计数器开辟？

![image-20250905173925897](assets/image-20250905173925897.png)



#  小米一面





# 零跑二面





# 天翼视联一面





# 小鹏hr三面





自我介绍

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。也积累了程序调试经验，能够快速定位程序问题。同时，我在 Linux 驱动开发和实时操作系统应用方面也积累了经验。我相信这些技术积累和项目经验能够让我快速融入团队，为公司的项目开发贡献价值。
```

## 你对小鹏的理解



小鹏定位于智能电动车 ，相比于传统的企业更强调 自动驾驶，只能座舱，车机交互等。 技术特色：自动驾驶领域小鹏在国内较早推进L2+L3级别的自动驾驶功能，推出了XNPG，目标是逐步实现全无人化。

自研芯片与操作系统：近年来开始布局自研芯片、域控制器和操作系统，减少对外部供应链的依赖，提高整车算力和软件迭代能力。

发展战略：强调智能化领先，坚持全站字眼，包括芯片、操作系统、智能驾驶算法等。

愿景是成为全球领先的智能电动车企业，不仅是造车，而是把汽车作为“智能移动终端”。



## 岗位职责分解

![image-20250911151522013](assets/image-20250911151522013.png)



## 偏好业务还是芯片

结合我过去的嵌入式和实时操作系统上的经验，以及这个岗位的理解：我更偏向于成为连接芯片硬件和上层业务应用的桥梁角色。



1. 我在之前的项木中对形象片研究有一定的兴趣和基础，接触过很多单片机 熟系其外设和总线架构，理解驱动开发。对贵公司的自研芯片，渴望能理解其架构，为其编写驱动和系统软件。
2. 我的技能栈和兴趣点更偏向于'芯片一侧的底层技术，但我始终保持着从'业务"视角来审视这些技术价值的习惯。 我认为这个岗位所需要的，正是我这样既愿意深入芯片底层，又具备系统视角和业务意识的工程师。我非常期待能在这个交叉领域深度耕耘。



# 汇顶二面

主管面 

![0baabe9f7c0fdf396fc6576c7f28bb0e](assets/0baabe9f7c0fdf396fc6576c7f28bb0e.jpg)



# 小米 二面准备



![image-20250912093109503](assets/image-20250912093109503.png)

![image-20250912093152738](assets/image-20250912093152738.png)

![image-20250912093353789](assets/image-20250912093353789.png)



小米家具  需要将设备物联

![c77ed43757977514c3c9837750f98277](assets/c77ed43757977514c3c9837750f98277.jpg)

![4c9534cf5c3a8941b4aa81ed54171b31](assets/4c9534cf5c3a8941b4aa81ed54171b31.jpg)



## RTT 

![](assets/image-20250912093526117-1757640927653-1.png)

三层  内核，组件和服务层， 软件包层



![image-20250912094106808](assets/image-20250912094106808.png)

![image-20250912094623734](assets/image-20250912094623734.png)

![image-20250912095004363](assets/image-20250912095004363.png)

![image-20250912113425909](assets/image-20250912113425909.png)

**![image-20250912113648036](assets/image-20250912113648036.png)**





# 开立二三面





面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。

我的技术方向主要集中在嵌入式系统和软件开发方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议，做过基于状态机的解析机制；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率。

通过项目实践，我积累了linux下项目开发经验，Qt作交互界面，多线程处理以及数据交互等关键技术，能够独立完成功能设计和测试工作。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持程序的开发与调试。期待能加入贵公司，为医疗设备相关软件的开发贡献自己的力量。





# CVTE 一面



1.上来先自我介绍 只记得下面这几个问题了，不过大概问了20个左右吧 2.C语言的指针常量和常量指针的区别 3.静态变量的作用 4.什么叫条件编译 5.C++的派生方式：三种public，private，protected 6.引用的使用方式 7.开漏和推挽的区别：开漏只能下拉，如果想上拉，需要外接上拉电阻；推挽上下都可以。 8.中断的流程是什么？我回答的是Linux下的，用gpio的，先将gpio转换为中断irq，然后进行一系列操作，具体不细说。 大概八股是上面的这些，还有些记不清了。 第二大部分：项目环节，挨个点进行拷打，所幸都回答的差不多。 第三大部分： 1.面试官介绍企业文化，问我假如入职后遇到某某某问题，我该怎么办。 2.问我怎么看待加班和出差？我听成了python和java有什么区别。然后给大家都搞笑了。 3.问我期望工作地点。 4.问我期望薪资

**什么叫条件编译**

- 使用预处理指令根据条件选择性编译代码，比如：

  ```
  #ifdef DEBUG
      printf("debug info\n");
  #endif
  ```

- 用途：调试、跨平台兼容、功能裁剪。

**分类与作用**：

1. **局部静态变量（函数内 `static`）**：在程序生命周期内只初始化一次，保留状态（比如计数器），作用域仍限制在函数内。
2. **文件作用域静态（全局前 `static`）**：限制链接可见性（internal linkage），防止被其他翻译单元访问（封装）。
3. **类静态成员（C++ `static`）**：属于类而非对象，所有对象共享一份。

**内存/初始化**：

- 零初始化的放 `.bss`，显式初始化的放 `.data`。
- C++11 起，函数内局部 static 的初始化是线程安全的（只初始化一次且有同步）。
- 





# 泰凌终面 hr

![image-20250925212321117](assets/image-20250925212321117.png)

```c
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str1, str2;
    // 读取第一行（带空白的字符串）
    getline(cin, str1);
    // 读取第二行（不带空白的字符串）
    getline(cin, str2);

    // 第一步：处理第一行，去除所有空白（空格、tab）
    string processedStr1;
    for (char c : str1) {
        if (c != ' ' && c != '\t') { // 只保留非空白字符
            processedStr1 += c;
        }
    }

    int count = 0;
    int len2 = str2.length();   // 第二行字符串的长度
    int len1 = processedStr1.length(); // 处理后第一行的长度

    // 第二步：统计第二行在处理后第一行中的出现次数（允许重叠）
    for (int i = 0; i <= len1 - len2; ++i) {
        bool isMatch = true;
        // 检查从位置 i 开始，是否能匹配第二行的所有字符
        for (int j = 0; j < len2; ++j) {
            if (processedStr1[i + j] != str2[j]) {
                isMatch = false;
                break;
            }
        }
        if (isMatch) {
            count++;
        }
    }

    // 输出匹配次数
    cout << count << endl;
    return 0;
}
```

![image-20250925212358193](assets/image-20250925212358193.png)

```c
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int N;
    cin >> N;  // 读取武士数量
    
    vector<int> qin(N), zhao(N);
    // 读取秦国武士战力
    for (int i = 0; i < N; ++i) {
        cin >> qin[i];
    }
    // 读取赵国武士战力
    for (int i = 0; i < N; ++i) {
        cin >> zhao[i];
    }
    
    // 对两国战力升序排序
    sort(qin.begin(), qin.end());
    sort(zhao.begin(), zhao.end());
    
    int ql = 0, qr = N - 1;  // 秦国战力的左右指针（左：最弱，右：最强）
    int zl = 0, zr = N - 1;  // 赵国战力的左右指针（左：最弱，右：最强）
    int winCount = 0;        // 赵国胜利场数
    
    // 贪心匹配：直到秦国所有武士都被匹配
    while (ql <= qr) {
        if (zhao[zr] > qin[qr]) {
            // 赵国最强能赢秦国最强 → 赢一场，双方最强都“退场”
            winCount++;
            zr--;
            qr--;
        } else {
            // 赵国最强赢不了秦国最强 → 用赵国最弱碰秦国最强（主动输）
            zl++;
            qr--;
        }
    }
    
    // 判断赵国是否赢的场数超过一半
    if (winCount > N / 2) {
        cout << "YES" << endl;
    } else {
        cout << "NO" << endl;
    }
    
    return 0;
}
```



![image-20250925212424742](assets/image-20250925212424742.png)

```c
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <string>

using namespace std;

struct Ticket {
    string flight;
    string seat;
    string name;
};

int main() {
    int n;
    cin >> n;
    cin.ignore();

    vector<Ticket> tickets;
    unordered_map<string, int> flightSeatMap;
    unordered_map<string, int> nameFlightMap;

    for (int i = 0; i < n; ++i) {
        string line;
        getline(cin, line);
        size_t pos1 = line.find(',');
        size_t pos2 = line.find(',', pos1 + 1);
        string flight = line.substr(0, pos1);
        string seat = line.substr(pos1 + 1, pos2 - pos1 - 1);
        string name = line.substr(pos2 + 1);

        tickets.push_back({flight, seat, name});
        string fsKey = flight + "|" + seat;
        flightSeatMap[fsKey] = i;
        string nfKey = name + "|" + flight;
        nameFlightMap[nfKey] = i;
    }

    int m;
    cin >> m;
    cin.ignore();

    for (int i = 0; i < m; ++i) {
        string line;
        getline(cin, line);
        size_t pos1 = line.find(',');
        size_t pos2 = line.find(',', pos1 + 1);
        size_t pos3 = line.find(',', pos2 + 1);
        string oldFlight = line.substr(0, pos1);
        string oldSeat = line.substr(pos1 + 1, pos2 - pos1 - 1);
        string newFlight = line.substr(pos2 + 1, pos3 - pos2 - 1);
        string newSeat = line.substr(pos3 + 1);

        string oldFsKey = oldFlight + "|" + oldSeat;
        if (flightSeatMap.find(oldFsKey) != flightSeatMap.end()) {
            int idx = flightSeatMap[oldFsKey];
            string name = tickets[idx].name;
            string oldNfKey = name + "|" + oldFlight;

            // 检查新航班号和新座位号是否已被其他机票占用
            string newFsKey = newFlight + "|" + newSeat;
            if (flightSeatMap.find(newFsKey) != flightSeatMap.end()) {
                int conflictIdx = flightSeatMap[newFsKey];
                // 删除冲突机票的映射
                string conflictName = tickets[conflictIdx].name;
                string conflictNfKey = conflictName + "|" + newFlight;
                nameFlightMap.erase(conflictNfKey);
            }

            // 检查新乘客名和航班号组合是否已被占用
            string newNfKey = name + "|" + newFlight;
            if (nameFlightMap.find(newNfKey) != nameFlightMap.end()) {
                int conflictIdx = nameFlightMap[newNfKey];
                // 删除冲突机票的映射
                string conflictFlight = tickets[conflictIdx].flight;
                string conflictSeat = tickets[conflictIdx].seat;
                string conflictFsKey = conflictFlight + "|" + conflictSeat;
                flightSeatMap.erase(conflictFsKey);
            }

            // 更新机票信息
            tickets[idx].flight = newFlight;
            tickets[idx].seat = newSeat;

            // 删除旧映射，添加新映射
            flightSeatMap.erase(oldFsKey);
            nameFlightMap.erase(oldNfKey);
            flightSeatMap[newFsKey] = idx;
            nameFlightMap[newNfKey] = idx;
        }
    }

    vector<Ticket> validTickets;
    for (int i = 0; i < tickets.size(); ++i) {
        const auto& ticket = tickets[i];
        string fsKey = ticket.flight + "|" + ticket.seat;
        string nfKey = ticket.name + "|" + ticket.flight;
        
        // 检查当前机票是否是最新状态
        if (flightSeatMap.count(fsKey) && flightSeatMap[fsKey] == i && 
            nameFlightMap.count(nfKey) && nameFlightMap[nfKey] == i) {
            validTickets.push_back(ticket);
        }
    }

    sort(validTickets.begin(), validTickets.end(), [](const Ticket& a, const Ticket& b) {
        if (a.flight != b.flight) return a.flight < b.flight;
        return a.seat < b.seat;
    });

    for (const auto& ticket : validTickets) {
        cout << ticket.flight << "," << ticket.seat << "," << ticket.name << endl;
    }

    return 0;
}
```



# 泰凌一二面



![image-20250925155624556](assets/image-20250925155624556.png)



谈薪  （base上海   深圳 苏州）

2.3*（12+2） 年终奖（1-3） 最低一个月，最高4个月   1W安家费

7% 7% （个人和公司）



午餐（午餐吃  或者  餐补25）  晚（有工作餐）

无住房补贴  无交通补贴

双休  （加班 正常7-8， 加班9-10点）



一年（1~3次调薪）  年中不是谁都有  年底100%都有



二选一：

宁波的人才引进（优点 多拿3W/1W   缺点 没应届生落户，异地就医 ） 还是在上海上班

选上海（ 落户好吧 ）



![4d49c520e9f1bb83fdd2d00f2bfb049b](assets/4d49c520e9f1bb83fdd2d00f2bfb049b.jpg)



#  仙工智能

通过 问了期望薪资



![image-20250928164146139](assets/image-20250928164146139.png)

## 10/14联系给了薪资

20*（12~14） 7%  无其他补贴 （住房或者交通都没有）

年假一年多休一天，带薪病假7天，加班（周末或者工作日有调休） 

我的回复是（1~2周给回复）。

![4ec0d6aa05a7d0f7acb1d79f052d731b](assets/4ec0d6aa05a7d0f7acb1d79f052d731b.jpg)



# 拓竹科技一面

手撕  回文个数

![image-20250929184519896](assets/image-20250929184519896.png)

![image-20250929184731613](assets/image-20250929184731613.png)

![8d84a9b4c6ac3629715e312ed17bc54a](assets/8d84a9b4c6ac3629715e312ed17bc54a.jpg)

使用DMA搬运效率一定高吗，什么情况下可以不使用

![image-20251104115252518](assets/image-20251104115252518.png)



# 新凯来 一面

![image-20250929184519896](assets/image-20250929184519896.png)

19.23-20.40   73min



上来手撕题   记事本或者本地IDE 不使用STL  int 123   ->321    120   21   -123  -321 



八股



巨多

cmake 

数据结构

进程通信

系统用调用

c++特性 

智能指针   深拷贝  浅拷贝   

动态多态  静态多态  数组链表区别   stack 场景  底层实现  

可重入和不可重入函数  





项目深挖   看源码

## 新凯来 业务主管面











# 中兴通讯一面（ai  算子）

腾讯会议



![image-20250930102643062](assets/image-20250930102643062.png)

![image-20250930104257003](assets/image-20250930104257003.png)

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。

我的技术方向主要集中在嵌入式系统和软件开发以及ai应用方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验，此外熟系linux下的字符设备驱动开发流程；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率，在面向任务适应的机器人操作技能学习项目中，利用llm生成强化学习奖励函数实现机器人技能自主学习，基于a2c网络设计横向多层特征连接与纵向动态可扩展迁移模型架构，显著提升机器人新技能学习效率。

通过项目实践，我积累了linux下项目开发经验，多线程处理以及数据交互等关键技术，能够独立完成功能设计和测试工作。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持程序的开发与调试。
我的介绍完毕，谢谢老师
```



手撕3*3矩阵

没有八股 全是项目

问了本科研究生成绩  排名  竞赛论文专利

反问  业务





LORA微调的全过程

了解transformer吗

cuda的计算图











































# 中科曙光 一面

腾讯会议

![image-20251009172750374](assets/image-20251009172750374.png)



![7f8c6a5959d04388e32eb5ee6751e81a](assets/7f8c6a5959d04388e32eb5ee6751e81a.jpg)

## 自我介绍

```
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。

我的技术方向主要集中在嵌入式系统和软件开发以及ai应用方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率，在面向任务适应的机器人操作技能学习项目中，利用llm生成强化学习奖励函数实现机器人技能自主学习，基于a2c网络设计横向多层特征连接与纵向动态可扩展迁移模型架构，显著提升机器人新技能学习效率。

通过项目实践，我积累了linux下项目开发经验，多线程处理以及数据交互等关键技术，能够独立完成功能设计和测试工作。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持程序的开发与调试。
我的介绍完毕，谢谢老师
```

![image-20251009174030533](assets/image-20251009174030533.png)

c++  和c的八股   项目问的很少

两轮技术一轮hr

![image-20251010093500070](assets/image-20251010093500070.png)

![image-20251013100454725](assets/image-20251013100454725.png)



 

# 文远知行  （一面）

 

忘记了没记





#  荣耀一面  （准备）

项目拷打

进程通信方式
线程同步方式
Linux设备驱动模型
Linux启动过程
Linux内存管理
IIcC的过程，时序
了解什么锁
C++11新特性
智能指针有哪些
了解什么设计模式
单例模式优缺点





![image-20250904145732006](assets/image-20250904145732006.png)





```
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发。也积累了程序调试经验。同时，我在 Linux 驱动开发和实时操作系统应用方面也积累了经验。我相信这些技术积累和项目经验能够让我快速融入团队，为公司的项目开发贡献价值。

```

https://vc.e.hihonor.com/j/752505907

![bf3356e9f9e04bcf8dccd20347bf9028](assets/bf3356e9f9e04bcf8dccd20347bf9028.jpg)



# 中科曙光二面

平行计算出b1~b4

![image-20251013100512118](assets/image-20251013100512118.png)

![image-20251013100601617](assets/image-20251013100601617.png)

![image-20251013100618623](assets/image-20251013100618623.png)

平行话化

![image-20251013100910738](assets/image-20251013100910738.png)

![image-20251013101405554](assets/image-20251013101405554.png)

![image-20251013101449535](assets/image-20251013101449535.png)

![image-20251013104626770](assets/image-20251013104626770.png)

多头

![image-20251013105135901](assets/image-20251013105135901.png)

![image-20251013105155290](assets/image-20251013105155290.png)

不同的head关注点不同

位置编码  e



![image-20251013105412064](assets/image-20251013105412064.png)

代表位置咨询

![image-20251013105647278](assets/image-20251013105647278.png)

![image-20251013105703521](assets/image-20251013105703521.png)

![image-20251013110136668](assets/image-20251013110136668.png)

一个encoder一个decoder

![image-20251013110348046](assets/image-20251013110348046.png)

![image-20251013113610553](assets/image-20251013113610553.png)

![image-20251013113632855](assets/image-20251013113632855.png)

![image-20251013144720183](assets/image-20251013144720183.png)

![image-20251013144802909](assets/image-20251013144802909.png)

decoder的input是前一个产生的 test output 

![image-20251013145138318](assets/image-20251013145138318.png)

多头注意力可以将每个词和前后多个词作attention，不同的头关注的侧重点不同



![image-20251013151510722](assets/image-20251013151510722.png)

LoRA微调





![image-20251013152540591](assets/image-20251013152540591.png)

![image-20251013154358728](assets/image-20251013154358728.png)

![image-20251013154410398](assets/image-20251013154410398.png)

任何人矩阵都可以进行奇异值分解

![image-20251013154508178](assets/image-20251013154508178.png)

![image-20251013154831319](assets/image-20251013154831319.png)

![image-20251013155044719](assets/image-20251013155044719.png)

![image-20251013155241227](assets/image-20251013155241227.png)

初始化A 高斯分布，B是全0

初始的data w=0不会干扰源模型

第二个做前向传播，输入数据x,  l,染香传播算梯度，更新

AB被试配成新任务的小炒。

  

![image-20251013155537294](assets/image-20251013155537294.png)

![image-20251013160042550](assets/image-20251013160042550.png)

![image-20251013160217320](assets/image-20251013160217320.png)





计算图

神经网络的中间表示，

什么是计算图

自动微分和计算图

图的调度和执行

计算图的挑战和未来

![image-20251013172241303](assets/image-20251013172241303.png)

![image-20251013172320524](assets/image-20251013172320524.png)

![image-20251013172448144](assets/image-20251013172448144.png)

![image-20251013172753762](assets/image-20251013172753762.png)

![image-20251013172850817](assets/image-20251013172850817.png)

张量和算子

![image-20251013173157556](assets/image-20251013173157556.png)

![image-20251013173348378](assets/image-20251013173348378.png)

## 内存泄漏的排查方法





```c
一、 什么是内存泄漏？
核心定义：程序在运行过程中，由于某些原因，未能释放不再使用的内存，导致这部分内存无法被再次使用，从而造成内存的浪费。随着时间推移，泄漏的内存会不断累积，轻则导致程序性能下降，重则使程序因内存耗尽而崩溃。

二、 内存泄漏的常见症状
在开始排查前，通常会有一些“蛛丝马迹”：

应用程序运行时间越长，占用的内存越多（在任务管理器、top 等工具中看到内存使用量持续稳定增长）。

应用程序响应速度逐渐变慢，甚至出现卡顿。

最终程序因 OutOfMemoryError (Java) 或 std::bad_alloc (C++) 等错误而崩溃。
    
三、 通用排查步骤与思路
一套标准的排查流程可以概括为以下几步，适用于大多数编程环境：

第一步：确认是否存在内存泄漏

监控内存使用情况：使用系统自带工具（如 Windows 任务管理器、Linux/Unix 的 top、htop）或更专业的监控系统（如 Prometheus + Grafana）长期观察应用程序的内存占用曲线。如果曲线呈稳定上升趋势且没有回落（尤其是在执行了应该释放内存的操作，如刷新页面、完成一个任务后），那么很可能存在内存泄漏。

第二步：定位泄漏点（最关键的步骤）

生成内存快照：在怀疑存在泄漏时，使用内存分析工具生成堆内存快照。

时机：最好在应用启动后（基准快照）、运行一段时间后、执行特定操作后分别生成快照，方便对比。

对比分析：对比不同时间点的内存快照，重点关注：

对象数量：哪些类的对象数量在持续异常增长？

内存占用：哪些对象占用的总内存最大且在增长？

分析引用链：找到可疑对象后，查看这些对象的 GC Roots 引用链。弄清楚是谁在持有对这些对象的引用，导致垃圾回收器无法回收它们。通常，泄漏的根本原因就是一个“意外的”强引用。

第三步：修复与验证

代码审查：根据分析结果，定位到具体的代码位置。常见原因包括：静态集合类滥用、未关闭的资源（文件流、数据库连接、网络连接）、监听器未注销、内部类持有外部类引用等。

修复代码：解除不必要的引用，例如将对象从集合中移除、将强引用改为弱引用、在 finally 块中关闭资源、正确注销监听器等。

验证修复：重复第一步的监控过程，确认修复后内存使用曲线恢复正常（呈锯齿状，有升有降）。    
    
    
```

![image-20251015102146644](assets/image-20251015102146644.png)

![image-20251015102758216](assets/image-20251015102758216.png)



## 段错误的排查方法

![image-20251015102626408](assets/image-20251015102626408.png)



# 寻影 面试



![image-20251015085831253](assets/image-20251015085831253.png)



```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。也积累了程序调试经验，能够快速定位程序问题。同时，我在 Linux 驱动开发和实时操作系统应用方面也积累了经验。我相信这些技术积累和项目经验能够让我快速融入团队，为公司的项目开发贡献价值。
```



![image-20251015171926097](assets/image-20251015171926097.png)



#  寻影二面】

![d3e22c87bfa1800a2db7e1a2c3fd5a1b](assets/d3e22c87bfa1800a2db7e1a2c3fd5a1b.jpg)

![50dcdc119daefe00a0c054ae6cba864d](assets/50dcdc119daefe00a0c054ae6cba864d.jpg)

![04ffbe7626189dc382b036f3f68737f1](assets/04ffbe7626189dc382b036f3f68737f1.jpg)

# 云胜智能

![image-20251015171948768](assets/image-20251015171948768.png)

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。也积累了程序调试经验，能够快速定位程序问题。同时，我在 Linux 驱动开发和实时操作系统应用方面也积累了经验。我相信这些技术积累和项目经验能够让我快速融入团队，为公司的项目开发贡献价值。
```

![4875a342c80194a085bd83abd57cb7b9](assets/4875a342c80194a085bd83abd57cb7b9.jpg)

# 中兴通讯一面

![1bdd74cdf5052e6da1f9c59e3b73e756](assets/1bdd74cdf5052e6da1f9c59e3b73e756.jpg)

# 中兴通讯二面

![image-20251017112928783](assets/image-20251017112928783.png)

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。
    
我的技术方向主要集中在嵌入式系统和软件开发以及ai应用方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验，此外熟系linux下的字符设备驱动开发流程；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划，也做过模型结构上的一些创新和设计。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率，在面向任务适应的机器人操作技能学习项目中，利用llm生成强化学习奖励函数实现机器人技能自主学习，基于a2c网络设计横向多层特征连接与纵向动态可扩展迁移模型架构，显著提升机器人新技能学习效率。

通过项目实践，我积累了linux下项目开发经验，多线程处理以及数据交互等关键技术，能够独立完成功能设计和测试工作。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持程序的开发与调试。
我的介绍完毕，谢谢老师
```







![3edf78c1f91063af2d98abfe02633521](assets/3edf78c1f91063af2d98abfe02633521.jpg)

![3d75cc5c26d551c5122140806d41b37e](assets/3d75cc5c26d551c5122140806d41b37e.jpg)

# 经纬恒润

![51189e064ebe53dc2daa0981155a421e](assets/51189e064ebe53dc2daa0981155a421e.jpg)

![5a5ebdc2a586d8388cfaaeb422f7ea42](assets/5a5ebdc2a586d8388cfaaeb422f7ea42.jpg)

#  海康

![b6d9a6a9763b8fdc96a85c165c898896](assets/b6d9a6a9763b8fdc96a85c165c898896.jpg)



# 华为



```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。

我的技术方向主要集中在嵌入式系统和软件开发以及ai应用方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验，此外熟系linux下的字符设备驱动开发流程；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率，在面向任务适应的机器人操作技能学习项目中，利用llm生成强化学习奖励函数实现机器人技能自主学习，基于a2c网络设计横向多层特征连接与纵向动态可扩展迁移模型架构，显著提升机器人新技能学习效率。

通过项目实践，我积累了linux下项目开发经验，多线程处理以及数据交互等关键技术，能够独立完成功能设计和测试工作。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持程序的开发与调试。
我的介绍完毕，谢谢老师
```

123面   等结果

# 未岚大陆 笔试/面试C++

##  一面



![image-20251031113232859](assets/image-20251031113232859.png)

## 自我介绍

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读控制科学与工程专业硕士学位，本科毕业于东华大学自动化专业。

我的技术方向主要集中在嵌入式系统和软件开发以及ai应用方面。能够熟练使用C/C++进行编程。具体来说，第一块是嵌入式实时系统，像RT-Thread这类系统，我有多线程架构的设计和开发经验；第二块是多源数据融合和运动控制，能够处理多种传感器信息，实现比较精准的协同控制；第三块是通信协议，熟悉UART、SPI、I2C这些常用硬件协议；最后也做过机器人智能交互相关开发，包括用Qt做界面，以及大模型集成和任务规划。

在近期项目中，我主要负责基于智能交互机器人综合抓取平台的开发，基于ROS, Gazebo，大语言模型，QT等多个模块，实现了自然语言文本指令到 任务序列规划、指令下发、日志存储与实时监控等功能界面，提升了人机协同作业的效率。

通过项目实践，我不仅完成了核心代码的编写，同时积累了一定的程序设计和调试经验，我积累了linux下项目开发经验，多线程处理以及数据交互等关键技术。同时，我也具备嵌入式系统、实时操作系统及硬件通信协议方面的基础，能更好地支持程序的开发与调试。
我的介绍完毕，谢谢老师
```

![image-20251103095938784](assets/image-20251103095938784.png)



## n多项目和八股

陈阳

关于二叉树  二叉搜索树

vector  clear的内容

c++怎么进行内存泄露的排查，工具

![image-20251103164139431](assets/image-20251103164139431.png)

红黑树和普通的完全平衡树之间的区别

![image-20251103164014403](assets/image-20251103164014403.png)

![image-20251103154630191](assets/image-20251103154630191.png)

# 影石 一面

嵌入式岗位

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。同时我也积累了程序调试经验，能够快速定位程序问题。我相信这些经验能够帮助我快速胜任贵岗位的工作。
    
我的介绍完毕，谢谢老师。
```



![image-20251103190710224](assets/image-20251103190710224.png)

单车项目 ：传感器信息采集（i2c,编码器，）， 图像处理，LCD显示，UART解析，SD卡写入

中断中：电机控制（共享GPS信息和陀螺仪信息，关中断的方式进行数据更改）

![image-20251105104323700](assets/image-20251105104323700.png)

![image-20251105104653287](assets/image-20251105104653287.png)

图像识别写入环形缓冲区，SD卡读取队列里面的数据

![image-20251105105842493](assets/image-20251105105842493.png)![image-20251105110918993](assets/image-20251105110918993.png)

![image-20251105111142891](assets/image-20251105111142891.png)

![image-20251105111209835](assets/image-20251105111209835.png)

![image-20251105111343481](assets/image-20251105111343481.png)





1. 堆和栈的区别，生长方向

```

特性	      栈 (Stack)	    堆 (Heap)
分配方式	自动分配/释放	   手动分配/释放
管理方式	编译器自动管理   程序员手动管理
分配速度	快	           慢
内存大小	较小(通常几MB)	较大(受系统内存限制)
碎片问题	无	           有
生长方向	向下(向低地址)	向上(向高地址)
访问速度	快	            慢
线程安全	每个线程独立	    全局共享
数据类型	局部变量、函数参数	动态分配的数据
```

2. 每个线程都有栈吗？，每个线程都有堆吗？

   ```
   是的，每个线程都有自己独立的栈空间。
   不，每个线程没有自己独立的堆，所有线程共享同一个堆空间。
   ```

   ![image-20251103191241565](assets/image-20251103191241565.png)

3. 做项目时，有没有遇到内存泄露的情况

```c
当然有！C语言的内存泄露问题甚至比C++更常见，因为C语言没有自动的内存管理机制，所有内存分配和释放都需要手动完成。
    malloc忘记 free
    检测C语言内存泄露的工具
      gcc -g -o program  main.c
      使用Valgrind --leak-check=full  --show-leak-kinds=all ./program
      预防内存泄漏的方法
    	1. 分配和释放成对出现 malloc free 
    	2. 设置指针为NULL after free
    
```

![image-20251103192030956](assets/image-20251103192030956.png)

![image-20251103192542631](assets/image-20251103192542631.png)

```c
7.代码规范建议
每个malloc都要有对应的free
在函数入口处分配，在出口处释放
使用goto或do-while(0)进行统一错误处理
释放后立即将指针设为NULL
定期使用静态分析工具检查代码
C语言的内存管理需要程序员格外小心，但通过良好的编程习惯和工具辅助，完全可以避免内存泄露问题。你有遇到具体的C语言内存泄露情况吗？我可以帮你分析解决！
```

4. 进程线程并发的安全问题是什么？怎么解决？

   并发：**并发编程又叫多线程编程。**，一个CPU在多个程序之间通过多路复用，并发性是对有限物理资源强制使用多用户共享以提高效率。

   ![image-20251103193340959](assets/image-20251103193340959.png)

```c
数据竞争问题（两个线程都去++一个变量）
死锁问题，// 两个线程互相等待，导致死锁！
竞态条件 (Race Condition)
解决方案：互斥锁，     
    	pthread_mutex_lock(&mutex);  // 加锁
		pthread_mutex_unlock(&mutex);  // 解锁
        读写锁  // 多个读者可以同时读，但写者独占
        条件变量 (Condition Variable)
        信号量 (Semaphore)
避免死锁的策略：
        锁顺序一致性
        使用原子操作
        避免共享数据    
```

![image-20251103193927228](assets/image-20251103193927228.png)

5. 互斥锁、自旋锁的区别？

```c

互斥锁和自旋锁是两种不同的同步机制，它们在等待方式和适用场景上有很大区别。
   互斥锁 (Mutex)
   pthread_mutex_lock(&mutex);    // 如果锁被占用，线程会睡眠
    // 执行临界区代码
    pthread_mutex_unlock(&mutex);  // 释放锁，唤醒等待线程
    自旋锁 (Spinlock)
     pthread_spin_lock(&spinlock);    // 如果锁被占用，线程会循环等待
    // 执行临界区代码
    pthread_spin_unlock(&spinlock);  // 释放锁

```

![image-20251103194224874](assets/image-20251103194224874.png)

![image-20251103194258080](assets/image-20251103194258080.png)

![image-20251103194344627](assets/image-20251103194344627.png)

![image-20251103194512780](assets/image-20251103194512780.png)

6. IIC SPI  协议

```
### 9.**I2C 总线在传送数据过程中共有三种类型信号？**

（1）开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。
（2）结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。
（3）应答信号：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲，表示已收到数据。CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障。

### 10. IIC配置主机模式端口应该怎么配置 ？

硬件模式：复用开漏输出、既不上拉也不下拉。（快速模式：400 Kbit/s）
软件模拟：推挽输出、配置上拉电阻。



### 11. I2C仲裁机制c

（多个主设备同时竞争总线控制权的问题）  低电平优先

![image-20250722165748089](assets/image-20250722165748089.png)

🧠 仲裁发生的时机：

✅ 发生在“数据传输前”的准备阶段：

1. 多个主设备想使用总线（例如发起读/写内存的操作）
2. 仲裁器（或总线控制器）判断哪个设备有更高优先级或谁先来请求
3. **只允许一个设备“获得总线使用权”**
4. 获胜的设备才能开始地址阶段（寻址） → 然后进入数据传输阶段



I2C 仲裁机制，理解了 线“与”（Wired-AND），就一目了然了。
简单说，它遵循“低电平优先”的原则，即谁先发送低电平谁就会掌握对总线的控制权。

就画 MT9P031 写操作，设备写地址为0xBA，片内寄存器地址为0x09，发送数据 0000 0010 和 1000 0100
```

7. 内核启动这块，中断上半部下半部？

   

   ```
   // 这会花费太长时间，导致其他中断被阻塞！
   ```

```c
内核中断分为  上半部（处理速度快，不耗实时的任务）和下半部（处理耗时任务，一般下半部在上半部处理后会会调用）
上半部：
	特点：
	快速执行：在中断上下文中运行
	不可睡眠：不能调用可能睡眠的函数
	关闭中断：运行时本地CPU中断被禁用
	关键操作：只做最必要的工作
完成耗时处理，可以使用多种机制
```

![image-20251103201243704](assets/image-20251103201243704.png)

![image-20251103203152362](assets/image-20251103203152362.png)

malloc calloc的区别

```


```

![image-20251103202312324](assets/image-20251103202312324.png)

linux  内核启动：

![aa7541610bbf9996550c6e8c65213709](C:/Users/jkx-pig/xwechat_files/wxid_28c7brmd4irv22_d21d/temp/RWTemp/2025-11/2a568e440c06a6f3cec43117ec5d6d43/aa7541610bbf9996550c6e8c65213709.jpg)

![image-20251103202628204](assets/image-20251103202628204.png)

8. 进程上下文，中断上下文可以用互斥锁吗

```c
这是一个非常重要的问题！进程上下文和中断上下文对互斥锁的使用有严格限制。
    
```

![image-20251103204130890](assets/image-20251103204130890.png)

![image-20251103204359433](assets/image-20251103204359433.png)

![image-20251103204410713](assets/image-20251103204410713.png)

中断中可以使用自旋锁的irq

![image-20251103204611540](assets/image-20251103204611540.png)

```
// 在进程上下文中使用互斥锁 - 安全
```

![image-20251103205533519](assets/image-20251103205533519.png)

9. 同步机制

   ```
   rtthread （ipc）
   信号量 ，互斥锁，事件标志组     消息队列，邮箱，
   
   ```

   ```
   linux
   管道  socket  信号sig  信号量  共享内存 消息队列
   ```

   ![image-20251103205851957](assets/image-20251103205851957.png)

![image-20251103205944051](assets/image-20251103205944051.png)

![image-20251103210047805](assets/image-20251103210047805.png)

C++和C联编程序，首先有一个写好的函数指针（参数个数定好），C++中也定义好了类，怎么让函数指针能够修改类中的内容，C++也能用函数指针

![image-20251105183859091](assets/image-20251105183859091.png)

```

```

C++的设计模式

```


```

哈希表冲突的解决方法：

```c
哈希表（Hash Table）通过哈希函数将“关键字（key）”映射到数组下标。
但由于哈希函数值域有限，不同的 key 可能映射到同一个位置，这就叫 哈希冲突（collision）。

哈希冲突的解决方法：
    开放地址法：如果当前位置被占用，就在表中寻找下一个空位置来放置元素。查找时同样沿着相同的探测序列去找。
    （1） 线性探测：hash_i=(hask(key)+i)%table_size 每次冲突往后挪一个格
    （2）二次探测：hash_i=(hash(hey)+i^2)%table_size 间隔增长，减少连续聚集。
    （3）双重哈希：hash_i=(hash1(key)+i*hash2(key))% table_size ,第二个哈希函数 hash2() 提供不同步长，避免聚集。
    链地址法：
    每个哈希桶不是存一个值，而是存一个链表（或者红黑树），冲突的数据元素挂在同一个链表上。
    
    
```

socket本地编程和远端编程的区别

```


```





# 影石二面

## 准备

```

```

### 进程上下文切换

进程的上下文切换不仅包含了虚拟内存，栈，全局变量等用户空间资源，还包含了内核堆栈，寄存器等内核空间。通常会把交换的信息保存到进程的PCB中，当要运行另一个进程的时候，需要从这个进程的PCB去除上下文然后恢复到CPU中，是的这个进程可以居胥运行。

![image-20251105210241705](assets/image-20251105210241705.png)



### 线程上下文切换

线程上下文切换因为共享同一个进程的地址空间和资源，只需要切换线程栈和PC等少量信息，不需要切换地址空间，避免了进程切换时的大量的内存映射表等资源开销，节省了时间。



![image-20251105210807698](assets/image-20251105210807698.png)

### 中断上下文切换



3. 
4. 
5. 什么是中断上下文，为什么在中断处理函数中不能休眠

中断上下文：当CPU接受到硬件设备的中断请求时，CPU会暂停当前运行的进程或线程，然后去执行相应的中断服务函数，这个时候操作系统需要保护和恢复一些关键的现场信息，会产生一个新的上下文环境，称为中断上下文。

中断上下文包含了一些与进程线程不同的数据结构和寄存器值，这些数据结构主要用于记录被打断前CPU正在执行的状态和被打断后CPU应该返回到哪里继续执行。

在linux系统中中断上下文通常包括以下内容：

中断号，寄存器总之，每次处理完一个硬件设备发出的中断请求后，操作系统都会恢复先前的运行状态，并继续执行之前被打断的进程或线程。因此，中断上下文是操作系统内核处理中断请求时必须要了解和处理的重要概念之一。



（普通进程上下文）CPU正常执行一个用户进程或者内核线程时，此时的执行环境称为进程上下文。

![image-20251105211221652](assets/image-20251105211221652.png)

![image-20251105212000098](assets/image-20251105212000098.png)

![image-20251105212459670](assets/image-20251105212459670.png)



3. 继续问什么是进程上下文



进程上下文是指内核代表进程执行时（如系统调用、异常处理），可以访问进程的用户空间内存，拥有完整的 `task_struct`，允许睡眠、调度切换。与中断上下文相对。



3. 介绍DMA，继续追问是什么驱使我用DMA而不是CPU

![image-20251105212605495](assets/image-20251105212605495.png)



3. 如果遇到IIC读写错误的问题，你会怎么排查

![image-20251105212937584](assets/image-20251105212937584.png)

3. 如果一个当驱动模块发生panic时，如何调试，继续问有没有做过rundump或者kkdump？

驱动模块内核崩溃怎么定位问题：

![image-20251105213402049](assets/image-20251105213402049.png)



3. 有无用过中断下半部的工作队列和Tasklet



3. 在工作队列中可以休眠吗

![image-20251105213848192](assets/image-20251105213848192.png)

![image-20251105214058952](assets/image-20251105214058952.png)

可以的

10.工作队列是工作在进程上下文还是中断上下文

![image-20251105214137672](assets/image-20251105214137672.png)

![image-20251105214200711](assets/image-20251105214200711.png)

进程上下文。

11.驱动能直接访问用户空间的内存吗

![image-20251105214242904](assets/image-20251105214242904.png)



12.c和c＋＋哪个熟

13.介绍c＋＋的RAII机制，追问实现自动释放内存的原理，动态管理内存的底层逻辑是？

![image-20251105214329127](assets/image-20251105214329127.png)

14.介绍一下多态，虚函数表是干嘛的

![image-20251105214353585](assets/image-20251105214353585.png)

15.介绍堆栈的区别

![image-20251105214401506](assets/image-20251105214401506.png)

16.有没有分析过内存泄露的问题

![image-20251105214435291](assets/image-20251105214435291.png)

17.介绍一下之前用gdb调试的经历

18.有没有用gdb调试过踩内存的问题

19.什么是优先级反转

![image-20251105214506680](assets/image-20251105214506680.png)



20.线程间有哪些同步机制，怎么解决并发竞争的问题

![image-20251105214533161](assets/image-20251105214533161.png)



21.进程间的通信方式有哪些

![image-20251105214602712](assets/image-20251105214602712.png)





类的内存布局

![image-20251105220013008](assets/image-20251105220013008.png)

![image-20251105220050319](assets/image-20251105220050319.png)

什么时候对象会有多个虚函数表指针

![image-20251105220750094](assets/image-20251105220750094.png)

![image-20251105220807751](assets/image-20251105220807751.png)







虚函数表一般存在哪里

![image-20251105221159132](assets/image-20251105221159132.png)



左值右值

![image-20251105221303763](assets/image-20251105221303763.png)

移动语义

![image-20251105221404080](assets/image-20251105221404080.png)

![image-20251105221428612](assets/image-20251105221428612.png)

RAII

![image-20251105221503879](assets/image-20251105221503879.png)



构造函数或析构函数抛异常会怎么样

- 构造函数可以抛异常，但必须在构造函数中 catch 并释放资源（因为构造函数抛异常不会调析构）
- 析构函数不能抛异常，析构函数中的异常必须在析构函数中处理
- ![image-20251105221708155](assets/image-20251105221708155.png)
- 

dynamic_cast 的作用

如何让一个对象只能在栈上申请

函数调用约定

SOLID 原则

用过哪些 STL 容器

STL 分配器的作用

vector 扩容会做什么事

迭代器失效

源文件到可执行文件的过程

![image-20251105221835782](assets/image-20251105221835782.png)



链接的过程

动态链接、got、plt

从 OS 视角看程序启动

```c
以linux为例，用户在终端输入./a.out->shell调用fork()创建子进程（创建唯一的pid,复制父进程的PCB,共用一个数据，写实才真正的复制）-》子进程调用execve加载a.out(记录代码段，数据段，初始化堆栈，加载动态库)-》动态链接器完成数据连接（符号解析和重定位）-》OS设置新进程的的程序计数器PC，———start->_start调用main-》执行代码。
c

```

进程地址空间

```
虚拟地址空间
代码段
数据段（.data,.bss）
堆
栈
文件映射去


```

OS 怎么管理堆

```
堆通过 malloc/new申请  free/delete释放，
1.堆初始化，初始分配一块很大的空间，维护一个空闲链表（初始时只有一个节点，对应整个初始化堆区）每个链表的节点记录一块空闲内存的起始地址和大小
2. 内存分配malloc
（1）查找空闲块，首次适配（第一个），最佳适配（大小最接近），最坏适配（最大空间）
（2）分割，分配快返回起始地址，剩余的假如空闲链表
（3）堆扩容：没找到扩展内存堆，
3.内存回收：合并相邻的空闲块

```

系统调用的过程



锁有哪些

```
互斥锁，读写锁，自旋锁，条件变量，原子操作，
```

什么时候会发生死锁

```
满足四个条件
```

怎么定位死锁

```c
定位死锁的核心在于 找出哪些线程持有了哪些资源，又在等待哪些资源，并确认是否存在循环等待链。

使用调试器，当程序卡住时，在调试器中暂停程序，查看所有线程的调用栈。
    
# 1. 在GDB中运行程序
gdb ./your_program
# 2. 程序卡住后，按 Ctrl+C 中断
(gdb) info threads
    info  mutex
    使用valgrind 检测思索，适合测试阶段。
    
    日志定位，无工具。
    
```

Makefile/CMakeLists 一般怎么写的

![image-20251106101208996](assets/image-20251106101208996.png)



内存泄漏或 crash 怎么调试

```c
内存泄漏 是指程序分配了内存但未能释放，导致可用内存不断减少，最终可能引发程序变慢或崩溃
    top查看
    使用GCC/Clang内置编译器 -fsanitize=address
 1.首选方法   
    # 编译时加入调试信息和AddressSanitizer
g++ -g -fsanitize=address -o my_program my_program.cpp
# 运行程序
./my_program
    输出：程序运行结束时（或过程中），AddressSanitizer 会打印一份详细的报告，明确指出泄漏的内存是在哪里分配的（文件名和行号）。这是首选方法。
    
   2.  valgrind 经典选择
    # 使用Memcheck工具（Valgrind默认工具）
valgrind --leak-check=full ./my_program
    报告分析：Valgrind 会报告
```

```c
内核dump crash
执行了非法操作
Crash 通常是由于程序执行了非法操作，如访问空指针、野指针、数组越界、栈溢出等，导致操作系统强行终止程序（在 Linux 下产生 Core Dump，在 Windows 下产生 Dr. Watson 日志）。
1.获取崩溃现场信息
在恒旭运行前，执行ulimit -c unlimited
    程序崩溃后，会生成一个core或者core.pid文件，使用GDB分析核心转储文件
    gdb ./my_program core
(gdb) bt # 打印崩溃时的调用栈
    
2.Visual Studio (Windows)： 自动定位到位置
3. Asan AddressSanitizer
    ASan 同样是解决 Crash 的神器。它能捕获的许多错误（如栈溢出、堆溢出、use-after-free）都会直接导致 Crash。

当使用 -fsanitize=address 编译的程序发生内存错误时，它会立即打印出错误的类型、内存地址和详细的调用栈，然后终止程序。这比分析 Core Dump 更直接。
4. GDB调试
```



线上问题怎么分析

![0ffbad68b5d985eb8298aa66693fc6b8](assets/0ffbad68b5d985eb8298aa66693fc6b8.jpg)



### 二面经验

常用的 STL 容器介绍

vector 和 deque 的区别

map 和 unordered_map 的区别

为什么 map 不用 AVL 树

![image-20251106103609754](assets/image-20251106103609754.png)

常用的锁有哪些

```c
互斥锁  递归锁 自旋锁 条件变量
```

了解无锁编程吗

```c
原子操作，减小线程切换开销
```

死锁产生的原因



怎么排查死锁

```c
使用GDB进行调试排查，反应是程序没有响应，进程都存活。
  日志排查，
  
  # 1. 在GDB中运行程序
gdb ./your_program
# 2. 程序卡住后，按 Ctrl+C 中断
(gdb) info threads
    info  mutex
    使用valgrind 检测思索，适合测试阶段。
    
```

讲讲 static 关键字

![image-20251106105801432](assets/image-20251106105801432.png)



静态全局变量和静态局部变量的初始化时机

```c
静态全局变量/静态成员变量：编译器分配内存，程序启动前（main之前）初始化，属于全局初始化阶段。

静态局部变量：第一次进入函数时初始化，生命周期之程序结束，线程安全。
```

为什么模板一般写在头文件

```
因为 C++ 的模板是 “编译时多态”。编译器需要在看到模板定义（实现）的同时，也看到它的使用（调用），以便根据具体的模板参数实例化出具体的代码（例如 vector<int> 和 vector<string> 是完全不同的两个类）。
如果模板的声明和定义分开在 .hpp 和 .cpp 文件，那么在编译使用该模板的其他 .cpp 文件时，编译器只有声明，没有定义，无法完成实例化，会导致链接错误。因此，通常将模板的声明和定义都放在头文件中。

```

![image-20251106110616623](assets/image-20251106110616623.png)













什么是虚拟内存

![image-20251106112121419](assets/image-20251106112121419.png)

常用的页面置换算法



进程、线程、协程



协程怎么利用多核



用过哪些协程库



IO 多路复用



TCP 三握四挥

为什么要三次握手，可以两次或者四次吗

三次挥手可以吗

TIME_WAIT 是什么

项目拷打

实习拷打

如何分析函数调用的开销

















## 1. 职业规划问题（3-5年）

```c
*短期（1-2年）：**
- 深入掌握公司产品线的嵌入式开发技术栈
- 独立承担模块开发，理解业务需求到技术实现的完整流程
- 在相机图像处理、低功耗优化等方向积累实战经验

**中期（3-5年）：**
- 成为某个技术领域的专家（如相机ISP调优、嵌入式AI部署）
- 具备系统架构设计能力，能主导复杂模块开发
- 培养团队协作和项目管理能力，向技术骨干发展

**长期愿景：**
- 希望在嵌入式视觉处理领域深耕
- 将AI算法与嵌入式硬件结合，为产品创造差异化竞争力
```

![image-20251103211009783](assets/image-20251103211009783.png)

![image-20251103211120329](assets/image-20251103211120329.png)

![image-20251103211151484](assets/image-20251103211151484.png)

![image-20251103211354672](assets/image-20251103211354672.png)

1. C语言的编译过程原理

预编译-编译-汇编-链接（可执行文件）

gcc -e test.c -0 test.i  (预处理  展开所有#include的头文件，处理所有#define,条件编译，)

![image-20251103212438520](assets/image-20251103212438520.png)

编译

gcc -s test.i -o test.s  (生成汇编代码  进行语法分析，词法分析 优化代码)

![image-20251103212427769](assets/image-20251103212427769.png)

汇编 

gcc -o test.s test.o 转化为机械码

![image-20251103212549667](assets/image-20251103212549667.png)

链接

将多个目标文件和库文件合并为可执行文件

gcc test.o -o test

![image-20251103212707995](assets/image-20251103212707995.png)

![image-20251103212750881](assets/image-20251103212750881.png)

![image-20251103212931624](assets/image-20251103212931624.png)



2. void*类型指针作用是什么，对比char*、int*等有什么优势

```c
void*是 C语言中一个非常重要且特殊的指针类型，
void *ptr;  // 定义一个void指针
特点：
	可以指向任意数据类型的内存地址
	不知道指向数据的类型和大小
	不能直接进行解引用操作
	不能进行指针算术运算
    
 void* 的主要优势
        泛型交换函数 - 可以交换任意类型的数据
        malloc/calloc/realloc返回void*，可以分配给任何类型
        memcpy/memset使用void*，可以操作任何类型的内存
         线程函数接受void*参数，可以传递任意数据
```

![image-20251103213329351](assets/image-20251103213329351.png)

![image-20251103213432381](assets/image-20251103213432381.png)

![image-20251103213813386](assets/image-20251103213813386.png)

3. malloc/calloc/realloc

![image-20251103214028653](assets/image-20251103214028653.png)

3. 大端模式和小端模式，内存对齐（char、int、char的结构体32位系统中占用多少个字节）   低地址存的是大数还是小数

```
低地址-》高地址
0x123456789  由高位-》低位 
如果ptr[0]=89  小端序  低地址低数
          =12  大端序  低地址存大数
```

![image-20251103214721338](assets/image-20251103214721338.png)

![image-20251103215346463](assets/image-20251103215346463.png)

4. SPI的四种模式，SPI如何和从机通信（通信协议帧）、如何实现一主多从（多条SS片选线）

![image-20251103215617205](assets/image-20251103215617205.png)



![image-20251103215816658](assets/image-20251103215816658.png)

5. I2C通信协议数据帧（指定地址写、当前地址读）、硬件如何连接

![image-20251103222034464](assets/image-20251103222034464.png)

6. I2C通信挂死如何进行排查（软件、硬件两方面）

![image-20251103222551255](assets/image-20251103222551255.png)

7. I2C上拉电阻选择？如果通信过程出现低电平0.4V高电平2.6V等中间电平原因是什么？

![image-20251103224046505](assets/image-20251103224046505.png)

![image-20251103224106989](assets/image-20251103224106989.png)

![e6cf81c3bc4f9b8c42e1caa0cdc74510](assets/e6cf81c3bc4f9b8c42e1caa0cdc74510.jpg)

![d2b2efc4aeff8c2bdfece012e78784da](assets/d2b2efc4aeff8c2bdfece012e78784da.jpg)

![e6ac96b0fd6914c35cbc89339c844ea5](assets/e6ac96b0fd6914c35cbc89339c844ea5.jpg)

![image-20251104100507251](assets/image-20251104100507251.png)

![image-20251104101207193](assets/image-20251104101207193.png)

![image-20251104101904902](assets/image-20251104101904902.png)

![image-20251104102141244](assets/image-20251104102141244.png)

printf是不可重入函数，内部是怎么实现的

![image-20251104102245590](assets/image-20251104102245590.png)

![image-20251104102532928](assets/image-20251104102532928.png)



UART对应的三种电平协议(TTL、RS232、RS485)，以及他们的特点、分别适用于哪些应用场景？



![image-20251104102952674](assets/image-20251104102952674.png)

![image-20251104104212075](assets/image-20251104104212075.png)

![image-20251104104322799](assets/image-20251104104322799.png)





CAN通信一主多从的总线仲裁（线与逻辑）

![image-20251106090145156](assets/image-20251106090145156.png)









# 荣耀 二面

10-23

```c
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。此外还做过智能机器人方面的研究，利用QT做交互界面，部署LLM实现智能交互功能,以及对训练网络的设计和修改。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发。也积累了程序调试经验。同时，我在 Linux 驱动开发和实时操作系统应用方面也积累了经验。我相信这些技术积累和项目经验能够让我快速融入团队，为公司的项目开发贡献价值。
```

![image-20251023091505266](assets/image-20251023091505266.png)

优缺点， 说应届生经验不足， 但是学习能力很强。

性格缺点，

![image-20251023091715553](assets/image-20251023091715553.png)

优点：

![image-20251023092336315](assets/image-20251023092336315.png)

以消费者为中心，以奋斗者为本，简单高效，开放创新，追求卓越的核心价值观



## 可能的问题

#### 1. 公司定位与愿景

- **核心定位**：全球领先的智能终端提供商。
- **品牌愿景**：创造一个属于每个人的智慧新世界。
- **关键信息**：荣耀（HONOR）最初是华为旗下的子品牌，于2020年11月独立出来。这次独立被业界视为一次“创业”，赋予了荣耀更大的灵活性和发展空间。

#### 2. 核心价值观与企业文化（回答的重中之重）

荣耀的文化带有强烈的“创业”精神和“技术”底色，你可以从以下几个关键词入手：

- **“笨鸟不等风”**
  - **含义**：这是荣耀最著名的文化内核。它意味着不投机、不等待风口，而是坚持通过自身努力和奋斗来创造价值。它强调**自主性、奋斗者和实干精神**。
  - **面试中可以说**：“我非常认同荣耀‘笨鸟不等风’的文化。这体现了一种不浮躁、脚踏实地、靠自身努力赢得市场的态度，我相信这对于技术和产品的长期深耕至关重要。”
- **“双轮驱动”极致产品主义**
  - **含义**：一个轮子是**不断理解消费者趋势和需求**，另一个轮子是**引领需求的技术创新**。两者结合，打造出极致的产品。
  - **面试中可以说**：“我了解到荣耀的产品哲学是‘双轮驱动’，既深度洞察用户，又坚持技术创新。这确保了产品不仅好用，还能给用户带来惊喜，这正是我作为一名[你的职位，如工程师/产品经理]所追求的工作目标。”





“面试官您好，我对荣耀公司确实做过一些功课，也非常钦佩这家公司。

首先，我非常认同荣耀‘笨鸟不等风’的企业精神。在我看来，这代表了一种不依赖外部红利、而是通过自身奋斗和技术创新去赢得市场的务实态度，这种文化对于一家科技公司的长远发展至关重要。

其次，我关注到荣耀‘双轮驱动’的产品理念——即一方面深度洞察用户，另一方面用技术创新来引领需求。这从我身边很多朋友对荣耀手机【比如Magic系列或数字系列】的评价中就能感受到，大家普遍认为产品体验很好，而且在【比如通信、续航或影像】方面有独特的优势。这让我觉得荣耀是一家真正在做‘极致产品’的公司。

最后，我知道荣耀从2020年底独立后，开启了一段新的创业历程，并且发展得非常迅速。这种充满挑战和机遇的‘创业’环境，对我个人来说非常有吸引力，它能让我快速成长，并和公司一起创造价值。

正因为如此，我特别希望能在荣耀这样一家兼具**技术创新基因**和**奋斗者精神**的公司里贡献自己的力量，并与公司共同成长。”



7.如果要你售卖一款产品，你将如何进行

![image-20251023100424258](assets/image-20251023100424258.png)

8.你觉得荣耀手机目前有哪些不足

![image-20251023100505507](assets/image-20251023100505507.png)



9.探讨了小米的营销和公关

![image-20251023100638796](assets/image-20251023100638796.png)

10.对自己的未来规划



# 三一重能

```
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。同时我也积累了程序调试经验，能够快速定位程序问题。我相信这些经验能够帮助我快速胜任贵岗位的工作。
    
我的介绍完毕，谢谢老师。



```

![image-20251111172828654](assets/image-20251111172828654.png)







#  百度系统架构



## 设计模式 23种

![image-20251110211928672](assets/image-20251110211928672.png)

![image-20251110211934162](assets/image-20251110211934162.png)

面向对象的（对象和属性）

  C++ QT JAVA GO

封装  继承  多态

![image-20251110213044329](assets/image-20251110213044329.png)

URL（描述类以及类和类之间的关系）



# 品驰医疗

![image-20251127090752208](assets/image-20251127090752208.png)

![ff7750e8ac8517b06ffed9505189f694](assets/ff7750e8ac8517b06ffed9505189f694.jpg)

```
自我介绍
面试官您好，我是靳可心，目前就读于山东大学控制科学与工程学院，攻读硕士学位，本科毕业于东华大学自动化专业，并通过保研来到山大继续深造。

我的技术方向主要集中在嵌入式系统与软件开发方面。能够熟练使用 C/C++ 进行编程，对实时操作系统如 RT-Thread有实际项目经验。同时也了解一些基础的 Linux 驱动开发流程。在硬件层面，我接触过 STM32  Cortex-M 系列 MCU，熟悉常用外设接口和通信协议，例如 UART、I2C 和 SPI。

在之前的项目中，我积累了一定的系统设计与实战经验。比如在双车协同控制系统中，我基于 RT-Thread 设计了一套高实时性的协同架构，通过多传感器数据融合，实现了三轮车与直立车的同控制，最终精准完成传球任务。该系统充分利用了 RT-Thread 的线程分层与优先级机制，协调图像处理、电机控制、传感器采集、LCD 监控和机间通信等多个任务并行运行。在通信层面，我采用 UART+DMA+IDLE 接收与环形缓冲区结合状态机的解析机制，实现了支持不定长帧和 CRC16 校验的可靠通信协议，并通过事件组灵活触发不同控制模式，保障双车协作的实时性和稳定性。

在项目中我不仅完成了核心功能的开发，还特别注重代码的可维护性和稳定性，比如通过模块化设计和状态机机制提升代码质量。同时我也积累了程序调试经验，能够快速定位程序问题。我相信这些经验能够帮助我快速胜任未来岗位的工作。
    
我的介绍完毕，谢谢老师。
```

![image-20250925155624556](assets/image-20250925155624556.png)

![image-20251127142741601](assets/image-20251127142741601.png)



![0a521a7b8037687a7af2f05e224ba422](assets/0a521a7b8037687a7af2f05e224ba422.jpg)





