# 1. RTOS概念及现成的引入





## 1.1 RTOS概念及线程的引入

![img](file:///C:\Users\jkx-pig\AppData\Local\Temp\ksohtml6508\wps1.jpg)





## 1.2 ARM架构以及汇编



### 1.2.1 arm架构

![image-20250702095707316](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702095707316.png)

![image-20250702095932360](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702095932360.png)

ARM精简指令集  对内存只有读写功能  运算在CPU

![image-20250702100147826](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702100147826.png)

汇编指令



![image-20250702101237590](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702101237590.png)



LDR      R0  [R3] 

![image-20250702100956164](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702100956164.png)

STR



ADD 、SUB

BL   跳转

PUSH   入栈

POP 出栈



举个例子

![image-20250702103435526](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702103435526.png)

![image-20250702104107269](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702104107269.png)







先保存-》执行-》恢复





保存什么：寄存器 r0-r12 （CPU中）  SP（栈顶指针R13）  LR（R14  程序返回地址）  PC（程序计数器 ）    栈（局部变量）

保存（R0-R15）    其中r0-r12应该要手动  其他自动

![image-20250702104652722](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702104652722.png)





创建线程

```c
#入口函数    栈   线程控制块
#include <rtthread.h>
#include <rtdevice.h>

#define THREAD_PRIORITY         15  //设置线程优先级
#define THREAD_STACK_SIZE       512 //设置线程栈大小
#define THREAD_TIMESLICE        15  //设置线程时间片大小

static char thread1_stack[1024];    //设置线程1的内存栈
static struct rt_thread thread1;    //定义线程1句柄

static struct rt_thread *thread2;   //定义线程2句柄指针


/* 线程1的入口函数 */
static void thread1_entry(void *parameter)
{
	const char *thread_name = "Thread1 run\r\n";
	volatile rt_uint32_t cnt = 0;
	
	/* 线程1 */
	while(1)
	{
		/* 打印线程1的信息 */
		rt_kprintf(thread_name);
		
		/* 延迟一会(比较简单粗暴) */
		for( cnt = 0; cnt < 100000; cnt++ )
		{
		}
	}
}

/* 线程2入口函数 */
static void thread2_entry(void *param)
{
	const char *thread_name = "Thread2 run\r\n";
	volatile rt_uint32_t cnt = 0;
	/* 线程2 */
	while(1)
	{
		/* 打印线程2的信息 */
		rt_kprintf(thread_name);
		
		/* 延迟一会(比较简单粗暴) */
		for( cnt = 0; cnt < 100000; cnt++ )
		{
		}
	}
}


int main(void)
{
	/* 初始化静态线程1，名称是Thread1，入口是thread1_entry */
    rt_thread_init(&thread1,               //线程句柄 
                   "thread1",              //线程名字
                   thread1_entry,          //入口函数
                   RT_NULL,                //入口函数参数
                   &thread1_stack[0],      //线程栈起始地址
                   sizeof(thread1_stack),  //栈大小
                   THREAD_PRIORITY,        //线程优先级
				   THREAD_TIMESLICE);      //线程时间片大小     
	/* 启动线程1 */
    rt_thread_startup(&thread1);           
	
	
	/* 创建动态线程2，名称是thread2，入口是thread2_entry*/
    thread2 = rt_thread_create("thread2",          //线程名字
                            thread2_entry,     //入口函数
							RT_NULL,           //入口函数参数
                            THREAD_STACK_SIZE, //栈大小
                            THREAD_PRIORITY,   //线程优先级
				            THREAD_TIMESLICE); //线程时间片大小

    /* 判断创建结果,再启动线程2 */
    if (thread2 != RT_NULL)
        rt_thread_startup(thread2);				   
				   
    return 0;
}





```

RT-THread专属内容

```c
#静态初始化方式   tr_thread_init($task1,"name",fun,静态栈地址可以是malloc 可以是全局变量数组，栈大小size,优先级，时间片)

#动态初始化方式  task2=rt_thread_create("name",fun,栈大小，优先级，时间片)


#结构体控制块  static  struct  rt_thread task1   看看结构体  控制块之中有什么内容
/*
2.1.1 线程结构体
rt_thread用来表示一个线程，它的重要成员如下：
thread->entry：函数指针
thread->parameter：函数参数
thread->stack_addr：栈的起始地址
thread->stack_size：栈大小
thread->sp：栈顶
thread->init_priority：初始优先级
thread->current_priority：当前优先级
thread->init_tick：一次能运行多少个tick
thread->remaining_tick：当次运行还剩多少个tick

*/
```

![image-20250702111743301](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702111743301.png)

![image-20250702111952558](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702111952558.png)

![image-20250702112009844](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702112009844.png)

![image-20250702112243567](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702112243567.png)

![image-20250702142535502](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702142535502.png)

![image-20250702145115144](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702145115144.png)



### 1.3 消息队列

![image-20250702145135487](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702145135487.png)

有线程想写队列但是队列满了会挂起   

rt_list_t   suspend_sender_thread

![image-20250702145304476](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702145304476.png)

想读挂起  在parent中   suspend_thread

![image-20250702145405491](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702145405491.png)

![image-20250702150301358](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702150301358.png)![image-20250702150527417](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702150527417.png)







![image-20250702161237432](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702161237432.png)



![image-20250702174624335](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250702174624335.png)





















# 2. 双车三轮的代码编写，RT-Thread  



线程创建

```




```











![image-20250704144413286](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704144413286.png)







![image-20250704144435513](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704144435513.png)



## 摄像头MT9V034



```c
/*********************************************************************************************************************
 * COPYRIGHT NOTICE
 * Copyright (c) 2019,逐飞科技
 * All rights reserved.
 * 技术讨论QQ群：一群：179029047(已满)  二群：244861897
 *
 * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
 * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
 *
 * @file       		总钻风
 * @company	   		成都逐飞科技有限公司
 * @author     		逐飞科技(QQ3184284598)
 * @version    		查看doc内version文件 版本说明
 * @Software 		IAR 8.3 or MDK 5.28
 * @Taobao   		https://seekfree.taobao.com/
 * @date       		2019-02-18
 * @note		
					接线定义：
					------------------------------------ 
						模块管脚                          单片机管脚
						SDA(51的RX)         查看SEEKFREE_MT9V03X.h文件中的MT9V03X_COF_UART_TX宏定义
						SCL(51的TX)         查看SEEKFREE_MT9V03X.h文件中的MT9V03X_COF_UART_RX宏定义
						场中断(VSY)          查看SEEKFREE_MT9V03X.h文件中的MT9V03X_VSYNC_PIN宏定义
						行中断(HREF)		        不接
						像素中断(PCLK)       查看SEEKFREE_MT9V03X.h文件中的MT9V03X_PCLK_PIN宏定义
						数据口(D0-D7)		查看SEEKFREE_MT9V03X.h文件中的MT9V03X_DATA_PIN宏定义
					------------------------------------ 
	
                                                默认分辨率是            188*50
                                                默认FPS                 50帧
 ********************************************************************************************************************/



#ifndef _SEEKFREE_MT9V03X_h
#define _SEEKFREE_MT9V03X_h

#include "common.h"
#include "zf_uart.h"
#include "ch32v10x.h"

//配置摄像头参数

#define MT9V03X_W               188            //图像宽度  范围1-752       RT102X RT105X RT106X 采集时列宽度必须为4的倍数
#define MT9V03X_H               70             //图像高度	范围1-480



//--------------------------------------------------------------------------------------------------
//引脚配置
//--------------------------------------------------------------------------------------------------
#define MT9V03X_COF_UART        UART_2              //配置摄像头所使用到的串口
#define MT9V03X_COF_UART_TX     UART2_TX_A2
#define MT9V03X_COF_UART_RX     UART2_RX_A3

#define MT9V03X_VSYNC_PIN       A1                  //场中断引脚
#define MT9V03X_VSYNC_IRQN      EXTI1_IRQn          //中断号

#define MT9V03X_DMA_CH          DMA1_Channel4
#define MT9V03X_DMA_IRQN        DMA1_Channel4_IRQn

#define MT9V03X_PCLK_PIN        A12                 //GPIO触发TIM引脚禁止随意修改
//--------------------------------------------------------------------------------------------------
//        摄像头数据接口
//        GPIO_IDR_ADDR(2,0)
//        第一个参数2代表着使用C口，可以选择0、1、2、3分别对应GPIO_PIN(A,0)，GPIO_PIN(B,0)，GPIO_PIN(C,0)，GPIO_PIN(D,0)
//        第二个参数0代表着使用的是C0 - C7口,
//        可以选择0、1、2、3，分别对应的是    该端口的X0-X7，X8-X15，X16-X23，X24-X31(这里x代表的是第一个字母，比如现在的就是C0-C7)
//--------------------------------------------------------------------------------------------------
#define MT9V03X_DATA_PIN        GPIO_IDR_ADDR(2, 1)


                        
//摄像头命令枚举
typedef enum
{
    INIT = 0,               //摄像头初始化命令
    AUTO_EXP,               //自动曝光命令
    EXP_TIME,               //曝光时间命令
    FPS,                    //摄像头帧率命令
    SET_COL,                //图像列命令
    SET_ROW,                //图像行命令
    LR_OFFSET,              //图像左右偏移命令
    UD_OFFSET,              //图像上下偏移命令
    GAIN,                   //图像偏移命令
    CONFIG_FINISH,          //非命令位，主要用来占位计数
    
    COLOR_GET_WHO_AM_I = 0xEF,
    SET_EXP_TIME = 0XF0,    //单独设置曝光时间命令
    GET_STATUS,             //获取摄像头配置命令
    GET_VERSION,            //固件版本号命令
	
    SET_ADDR = 0XFE,        //寄存器地址命令
    SET_DATA                //寄存器数据命令
}CMD;
     
     
     
extern uint8    receive[3];         //仅用于接收配置信息时所用  禁止用户使用该变量
extern uint8    receive_num;        //仅用于接收配置信息时所用  禁止用户使用该变量
extern vuint8   uart_receive_flag;  //仅用于接收配置信息时所用  禁止用户使用该变量


extern vuint8   mt9v03x_finish_flag;//一场图像采集完成标志位
extern uint8    mt9v03x_image[MT9V03X_H][MT9V03X_W];


void set_config(UARTN_enum uartn, int16 buff[CONFIG_FINISH-1][2]);
void get_config(UARTN_enum uartn, int16 buff[CONFIG_FINISH-1][2]);
uint16 get_version(UARTN_enum uartn);
uint16 set_exposure_time(UARTN_enum uartn, uint16 light);

void mt9v03x_init(void);
void mt9v03x_vsync(void);
void mt9v03x_dma(void);
void mt9v03x_uart_callback(void);
void seekfree_sendimg_03x(UARTN_enum uartn, uint8 *image, uint16 width, uint16 height);




#endif


```



这些函数都是干嘛的  为什么要有串口，DMA，场中断、行中断、采集一贞图片的时间、怎么传输数据的

初始化摄像头类型、参数、定时器中断干嘛的在这里

```
void mt9v03x_init(void);
功能：初始化摄像头模块

内容一般包括：

配置摄像头的默认参数（如分辨率、曝光、FPS 等）

配置 DMA、GPIO、定时器、中断

启动摄像头数据采集逻辑（如使能 VSYNC 中断）




```

每一帧的起始发送信号  告诉DMA可以开始采集GPIO的数据到N内存了  采集完设置标志位MT9V03_FINISH)FLAG标志位



```makedown
void mt9v03x_vsync(void);
功能：场中断（VSYNC）处理函数

当摄像头输出 VSYNC 信号（表示一帧图像采集开始）时，触发此函数：

一般会在这里启动 DMA 采集

设置采集完成标志位 mt9v03x_finish_flag

是实现“逐帧采集”的关键控制点
```

dma彩信函数

```c
void mt9v03x_dma(void);
功能：配置并启动 DMA 采集

使用 DMA（Direct Memory Access，直接内存访问）将摄像头输出的数据从 GPIO 口快速传输到内存中的图像数组 mt9v03x_image 中

DMA 是“无CPU参与”的高效传输方式，避免了逐字节读取造成 CPU 卡顿


void mt9v03x_dma_init(void)
{
    uint8 data_pin,num;


    //摄像头数据引脚初始化
    data_pin = (uint8)(((MT9V03X_DATA_PIN - (GPIOA_BASE+8)) >> 10) << 5) +
                (((MT9V03X_DATA_PIN - (GPIOA_BASE+8)) & 0x0F) << 3);

    for(num=7; num>0; num--)
    {
        gpio_init((PIN_enum)(num + data_pin), GPI, 0, IN_FLOAT);
    }


    //DMA摄像头初始化
    camera_dma_init(MT9V03X_DMA_CH,(uint32)MT9V03X_DATA_PIN, (uint32)camera_buffer_addr, MT9V03X_H*MT9V03X_W);
    nvic_init(MT9V03X_DMA_IRQN, 1, 0, ENABLE);          //中断配置
}

```



串口是用来配置和获取设置信息的、数据是通过DMA来传输的。



```
void mt9v03x_uart_callback(void);
功能：串口接收配置指令的中断回调函数

摄像头的某些参数（如曝光时间、帧率）是通过 UART 串口配置 的

当 PC 或上位机通过串口发来配置命令时，这个函数会响应并解析命令
```

seekfree_sendimg_03x  通过串口发送图像给上位机



```
void seekfree_sendimg_03x(UARTN_enum uartn, uint8 *image, uint16 width, uint16 height);

```

![image-20250704155634070](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704155634070.png)





一帧图像开始（VSYNC上升沿）
       ↓
mt9v03x_vsync()                // 开启 DMA 采集
       ↓
DMA 自动搬运图像数据 → mt9v03x_image[][] 缓冲区
       ↓
一帧图像搬运完成 → 触发 DMA 中断
       ↓
DMA1_Channel4_IRQHandler()     // 中断响应
       ↓
调用 mt9v03x_dma()            // 设置采集完成标志 + 关闭 DMA

![image-20250704161702591](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704161702591.png)









![image-20250704161758316](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704161758316.png)





![image-20250704161855918](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704161855918.png)

![image-20250704162004755](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704162004755.png)



## 3.ADC 模数转换模块





zf_adc.h文件 

```c
/*********************************************************************************************************************
* COPYRIGHT NOTICE
* Copyright (c) 2019,逐飞科技
* All rights reserved.
* 技术讨论QQ群：一群：179029047(已满)  二群：244861897
*
* 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
* 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
*
* @file				adc
* @company			成都逐飞科技有限公司
* @author			逐飞科技(QQ3184284598)
* @version			查看doc内version文件 版本说明
* @Software			IAR 8.3 or MDK 5.28
* @Target core		MM32F3277
* @Taobao			https://seekfree.taobao.com/
* @date				2021-02-22
********************************************************************************************************************/

#ifndef _zf_adc_h
#define _zf_adc_h

#include "common.h"

// 枚举 ADC 引脚通道	此枚举定义不允许用户修改
typedef enum																		// 枚举ADC通道
{
	ADC1_CH00_A00		= 0x000,													// 0x000[CH00] 0x000[A group] 0x000[pin  0]
	ADC1_CH01_A01		= 0x101,													// 0x100[CH01] 0x000[A group] 0x001[pin  1]
	ADC1_CH02_A02		= 0x202,													// 0x200[CH02] 0x000[A group] 0x002[pin  2]
	ADC1_CH03_A03		= 0x303,													// 0x300[CH03] 0x000[A group] 0x003[pin  3]
	ADC1_CH04_A04		= 0x404,													// 0x400[CH04] 0x000[A group] 0x004[pin  4]
	ADC1_CH05_A05		= 0x505,													// 0x500[CH05] 0x000[A group] 0x005[pin  5]
	ADC1_CH06_A06		= 0x606,													// 0x600[CH06] 0x000[A group] 0x006[pin  6]
	ADC1_CH07_A07		= 0x707,													// 0x700[CH07] 0x000[A group] 0x007[pin  7]
	ADC1_CH08_B00		= 0x810,													// 0x800[CH08] 0x010[B group] 0x000[pin  0]
	ADC1_CH09_B01		= 0x911,													// 0x900[CH09] 0x010[B group] 0x001[pin  1]
	ADC1_CH10_C00		= 0xA20,													// 0xA00[CH10] 0x020[C group] 0x000[pin  0]
	ADC1_CH11_C01		= 0xB21,													// 0xB00[CH11] 0x020[C group] 0x001[pin  1]
	ADC1_CH12_C02		= 0xC22,													// 0xC00[CH12] 0x020[C group] 0x002[pin  2]
	ADC1_CH13_C03		= 0xD23,													// 0xD00[CH13] 0x020[C group] 0x003[pin  3]

	ADC1_CH14_TEMP		= 0xE80,													// 温度传感器通道
	ADC1_CH15_VS		= 0xF80,													// 内部参考电压通道

	ADC2_CH00_A00		= 0x000,													// 0x000[CH00] 0x000[A group] 0x000[pin  0]
	ADC2_CH01_A01		= 0x101,													// 0x100[CH01] 0x000[A group] 0x001[pin  1]
	ADC2_CH02_A02		= 0x202,													// 0x200[CH02] 0x000[A group] 0x002[pin  2]
	ADC2_CH03_A03		= 0x303,													// 0x300[CH03] 0x000[A group] 0x003[pin  3]
	ADC2_CH04_A04		= 0x404,													// 0x400[CH04] 0x000[A group] 0x004[pin  4]
	ADC2_CH05_A05		= 0x505,													// 0x500[CH05] 0x000[A group] 0x005[pin  5]
	ADC2_CH06_A06		= 0x606,													// 0x600[CH06] 0x000[A group] 0x006[pin  6]
	ADC2_CH07_A07		= 0x707,													// 0x700[CH07] 0x000[A group] 0x007[pin  7]
	ADC2_CH08_B00		= 0x810,													// 0x800[CH08] 0x010[B group] 0x000[pin  0]
	ADC2_CH09_B01		= 0x911,													// 0x900[CH09] 0x010[B group] 0x001[pin  1]
	ADC2_CH10_C00		= 0xA20,													// 0xA00[CH10] 0x020[C group] 0x000[pin  0]
	ADC2_CH11_C01		= 0xB21,													// 0xB00[CH11] 0x020[C group] 0x001[pin  1]
	ADC2_CH12_C02		= 0xC22,													// 0xC00[CH12] 0x020[C group] 0x002[pin  2]
	ADC2_CH13_C03		= 0xD23,													// 0xD00[CH13] 0x020[C group] 0x003[pin  3]
	ADC2_CH14_C04		= 0xE24,													// 0xE00[CH14] 0x020[C group] 0x004[pin  4]
	ADC2_CH15_C05		= 0xF25,													// 0xF00[CH15] 0x020[C group] 0x005[pin  5]

	ADC3_CH00_A00		= 0x000,													// 0x000[CH00] 0x000[A group] 0x000[pin  0]
	ADC3_CH01_A01		= 0x101,													// 0x100[CH01] 0x000[A group] 0x001[pin  1]
	ADC3_CH02_A02		= 0x202,													// 0x200[CH02] 0x000[A group] 0x002[pin  2]
	ADC3_CH03_A03		= 0x303,													// 0x300[CH03] 0x000[A group] 0x003[pin  3]
	ADC3_CH04_F06		= 0x456,													// 0x400[CH04] 0x050[F group] 0x006[pin  6]
	ADC3_CH05_F07		= 0x557,													// 0x500[CH05] 0x050[F group] 0x007[pin  7]
	ADC3_CH06_F08		= 0x658,													// 0x600[CH06] 0x050[F group] 0x008[pin  8]
	ADC3_CH07_F09		= 0x759,													// 0x700[CH07] 0x050[F group] 0x009[pin  9]
	ADC3_CH08_F10		= 0x85A,													// 0x800[CH08] 0x050[F group] 0x00A[pin 10]
	ADC3_CH09_B01		= 0x911,													// 0x900[CH09] 0x010[B group] 0x001[pin  1]
	ADC3_CH10_C00		= 0xA20,													// 0xA00[CH10] 0x020[C group] 0x000[pin  0]
	ADC3_CH11_C01		= 0xB21,													// 0xB00[CH11] 0x020[C group] 0x001[pin  1]
	ADC3_CH12_C02		= 0xC22,													// 0xC00[CH12] 0x020[C group] 0x002[pin  2]
	ADC3_CH13_C03		= 0xD23,													// 0xD00[CH13] 0x020[C group] 0x003[pin  3]
	ADC3_CH14_C04		= 0xE24,													// 0xE00[CH14] 0x020[C group] 0x004[pin  4]
	ADC3_CH15_C05		= 0xF25,													// 0xF00[CH15] 0x020[C group] 0x005[pin  5]
}ADCCH_enum;

// 枚举 ADC 分辨率	此枚举定义不允许用户修改
typedef enum																		// 枚举ADC通道
{
	ADC_12BIT,																		//12位分辨率
	ADC_11BIT,																		//11位分辨率
	ADC_10BIT,																		//10位分辨率
	ADC_9BIT,																		//9位分辨率
	ADC_8BIT,																		//8位分辨率
}ADCRES_enum;

// 枚举 ADC 模块号	此枚举定义不允许用户修改
typedef enum
{
	ADC_1,																			// ADC1
	ADC_2,																			// ADC2
	ADC_3,																			// ADC3
}ADCN_enum;

extern ADC_TypeDef *adc_index[3];

void	adc_init		(ADCN_enum adc, ADCCH_enum ch, ADCRES_enum resolution);
uint16	adc_convert		(ADCN_enum adc, ADCCH_enum ch);
uint16	adc_mean_filter	(ADCN_enum adc, ADCCH_enum ch, uint8 count);

#endif

```

 这是mm32g3277官方的库，如果我使用五个电感，那是使用ADC1的随便五个通道还是什么意思，怎么初始化，怎么获得电感数值 

![image-20250704173357077](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704173357077.png)

```c

#include "zf_adc.h"

void my_adc_init(void)
{
    adc_init(ADC_1, ADC1_CH00_A00, ADC_12BIT);
    adc_init(ADC_1, ADC1_CH01_A01, ADC_12BIT);
    adc_init(ADC_1, ADC1_CH02_A02, ADC_12BIT);
    adc_init(ADC_1, ADC1_CH03_A03, ADC_12BIT);
    adc_init(ADC_1, ADC1_CH04_A04, ADC_12BIT);
}
初始化每个通道为 12 位分辨率（0~4095）
    
    
uint16 adc_l1, adc_l2, adc_l3, adc_l4, adc_l5;

void read_inductor_adc(void)
{
    adc_l1 = adc_mean_filter(ADC_1, ADC1_CH00_A00, 10);  // 平均10次
    adc_l2 = adc_mean_filter(ADC_1, ADC1_CH01_A01, 10);
    adc_l3 = adc_mean_filter(ADC_1, ADC1_CH02_A02, 10);
    adc_l4 = adc_mean_filter(ADC_1, ADC1_CH03_A03, 10);
    adc_l5 = adc_mean_filter(ADC_1, ADC1_CH04_A04, 10);
}


```

###  我想使用RT-Thread系统单创建一个线程采集ADC信息，在定时器中进行电机方向PD控制，速度PI控制，怎么做



![image-20250704174710145](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704174710145.png)

明白了，你使用 **RT-Thread 系统**，希望将 **ADC采集线程得到的结果通过 mailbox（邮箱机制）传递给定时器控制逻辑使用**，这是完全合理且推荐的做法，尤其适合任务间或任务-中断间安全通信

![image-20250704174819874](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250704174819874.png)

```c

void ADC_GetAllValue()
{
//    for (uint8 t = 0; t < 5; ++t)
//    {
        adc[0].lastvalue=adc_mean_filter(adc[0].channel,ADC_CONVERT_BIT,ADC_TIMES_ONCE);
        adc[4].lastvalue=adc_mean_filter(adc[4].channel,ADC_CONVERT_BIT,ADC_TIMES_ONCE);
//    }
    adc[0].lastvalue = adc[0].lastvalue*300/4095;
    adc[4].lastvalue = adc[4].lastvalue*300/4095;
}

```

![image-20250705102718430](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250705102718430.png)





![image-20250705102736894](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250705102736894.png)





![image-20250705102747213](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250705102747213.png)





## 智能车硬件

```c
1.摄像头：
    总钻风：  
    	UART8(发送接收设置指令  发送图像到串口)
    	Timer1(提供时钟 每一个时钟 将一个像素经过DMA搬运到内存)
	TXD			PE0 <单片机的 UART8 RX>
	RXD			PE1 <单片机的 UART8 TX>
	PLCK		PE7 <单片机的 TIM1_ETR 信号 对应 DMA1_CH4 的 TIM1_TRIG >
	VSYNC		PE8
	HREF		MM32采集不需要使用该信号
	DATA		PF0-PF7
  2.TFT1.8
     	SPI3( 协议)
	SCL/D0		PD4		<单片机的 SPI3 SCK>
	SDA/D1		PD6		<单片机的 SPI3 MOSI>
	RST			PD13
	DC			PD5
	CS			PD7
	BL			PD11
    
   3. ADC   （差比和  怎么PD控制转向）
    L1			PA4		<单片机的 ADC2_CH4>
	L2			PA5		<单片机的 ADC2_CH5>
	L3			PA6		<单片机的 ADC2_CH6>
	L4			PA7		<单片机的 ADC2_CH7>

	L5			PC0		<单片机的 ADC3_CH10>
	L6			PC1		<单片机的 ADC3_CH11>
	L7			PC2		<单片机的 ADC3_CH12>
	L8			PC3		<单片机的 ADC3_CH13>
    
    4. 两个电机  TIM5  PWM(两路输出+两路方向)  32bit
    1DIR   PA0   <单片机 TIM5_CH1>
    1PWM   PA1  <单片机  TIM5_CH2>
    2DIR   PA2  <单片机  TIM5_CH3>
    2PWM   PA3  <单片机  TIM5_CH4> 
    
    5.两个编码器  TIM3/4   16bit 16bit
    编码器1
    A/LSB   PB4   <单片机的 TIM3_ENC1> TIM_3_ENC1_B04
    B/DIR  PB5    <单片机的 TIM3_ENC2> TIM_3_ENC1_B05
    编码器2
	A/LSB		PB6		<单片机的 TIM4_ENC1>
	B/DIR		PB7		<单片机的 TIM4_ENC2>
    
```

### 正交解码 encoder

```C
#初始化A相B相  两个编码器 初始化就两句话
tim_encoder_init(TIM3,TIM_3_ENC1_B04,TIM_3_ENC1_B05)
tim_encoder_init(TIM4,TIM_4_ENC1_B04,TIM_4_ENC1_B05)
    
```







![image-20250705150320097](C:\Users\jkx-pig\AppData\Roaming\Typora\typora-user-images\image-20250705150320097.png)
