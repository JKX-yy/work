

# C++多线程机制

C++11标准引入了原生的多线程支持，使得开发者可以直接使用标准库编写跨平台的多线程程序，而不需要依赖平台特定的API。以下是C++多线程机制的主要组成部分：

## 1. 线程管理 (`<thread>`)

### 创建线程

```
#include <iostream>
#include <thread>

void thread_function() {
    std::cout << "Hello from thread!\n";
}

int main() {
    std::thread t(thread_function); // 创建并启动线程
    t.join(); // 等待线程结束
    return 0;
}
```

### 线程基本操作

- `join()`: 等待线程完成
- `detach()`: 分离线程，使其独立运行
- `joinable()`: 检查线程是否可join

## 2. 互斥量 (`<mutex>`)

### 基本互斥量

cpp



Copy



Download

```
#include <mutex>

std::mutex mtx;

void safe_print(const std::string& msg) {
    mtx.lock();
    std::cout << msg << std::endl;
    mtx.unlock();
}
```

### 更安全的RAII风格锁

cpp



Copy



Download

```
void safer_print(const std::string& msg) {
    std::lock_guard<std::mutex> guard(mtx);
    std::cout << msg << std::endl;
    // 离开作用域时自动解锁
}
```

### 其他互斥量类型

- `std::recursive_mutex`: 可重入互斥量
- `std::timed_mutex`: 带超时的互斥量
- `std::recursive_timed_mutex`: 可重入且带超时的互斥量

## 3. 条件变量 (`<condition_variable>`)

用于线程间同步：

cpp



Copy



Download

```
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void worker_thread() {
    std::unique_lock<std::mutex> lk(mtx);
    cv.wait(lk, []{return ready;}); // 等待条件满足
    // 处理任务
}

void main_thread() {
    {
        std::lock_guard<std::mutex> lk(mtx);
        ready = true;
    }
    cv.notify_one(); // 通知等待的线程
}
```

## 4. 原子操作 (`<atomic>`)

提供无锁的线程安全操作：

cpp



Copy



Download

```
#include <atomic>

std::atomic<int> counter(0);

void increment() {
    for (int i = 0; i < 1000; ++i) {
        ++counter; // 原子操作
    }
}
```

## 5. 异步操作 (`<future>`)

### `std::async`

cpp



Copy



Download

```
#include <future>

int compute() {
    // 长时间计算
    return 42;
}

int main() {
    std::future<int> result = std::async(std::launch::async, compute);
    // 可以做其他事情
    int value = result.get(); // 获取结果
}
```

### `std::promise` 和 `std::future`

cpp



Copy



Download

```
void worker(std::promise<int> prom) {
    prom.set_value(42); // 设置值
}

int main() {
    std::promise<int> prom;
    std::future<int> fut = prom.get_future();
    
    std::thread t(worker, std::move(prom));
    int value = fut.get(); // 获取值
    t.join();
}
```

## 6. 线程局部存储 (`thread_local`)

cpp



Copy



Download

```
thread_local int thread_specific_value = 0;

void thread_function() {
    thread_specific_value++; // 每个线程有自己的副本
}
```

## 7. 其他实用工具

### `std::call_once`

cpp



Copy



Download

```
std::once_flag flag;

void init() {
    std::call_once(flag, []{ /* 初始化代码，只执行一次 */ });
}
```

### `std::shared_mutex` (C++17)

读写锁，允许多个读或单个写：

cpp



Copy



Download

```
std::shared_mutex smtx;

void reader() {
    std::shared_lock lock(smtx); // 共享锁
    // 读取数据
}

void writer() {
    std::unique_lock lock(smtx); // 独占锁
    // 修改数据
}
```

## 最佳实践

1. 优先使用RAII风格的锁管理 (`lock_guard`, `unique_lock`)
2. 避免直接调用`lock()`和`unlock()`，以防忘记解锁
3. 小心死锁情况，尽量按固定顺序获取多个锁
4. 考虑使用`std::async`替代直接创建线程
5. 对于简单计数器，优先使用原子操作
6. 避免过度使用线程，线程创建和切换有开销

C++的多线程机制提供了强大的工具，但也需要开发者谨慎使用以避免竞态条件、死锁等常见问题。